Introduction to PHP
History of PHP

PHP was created in 1994 and is one of the foundational technologies of modern web development. Given all the new technologies used today, is there still a place for PHP?

PHP remains one of the widest used server-side technologies on the internet. It provides the underlying code for many popular content management systems (CMS) including WordPress, Drupal, and Joomla. A CMS allows users to create and update their own websites without having to write a lot of complex code themselves.

PHP also provides the underlying code for many e-commerce sites including WooCommerce and Magento. These e-commerce platforms offer a number of tools for selling products online. This way companies can focus on other aspects of their business without having to implement complex programming logic from scratch.

PHP contains built-in functionality for interacting with web data, Vanilla PHP, or PHP without any other tools, can be used on its own to create web application back-ends. But we don’t have to reinvent the wheel every time! Once we’re comfortable with the basics of the PHP language, we have our pick of powerful PHP frameworks to choose from! These frameworks provide scaffolding and solutions to common problems in back-end web development. Some popular PHP frameworks are Laravel, CakePHP, and Symfony.
How is PHP used in HTML?

PHP is often used to build dynamic web pages. A dynamic web page is one where each visitor to the website gets a customized page that can look different than how the site looks to another visitor. This is in contrast to static web pages which provide the same content to each visitor.

Static vs. Dynamic Web Sites Using PHP

In order to create this dynamic behavior, PHP was designed to work closely with HTML. PHP can be used directly in-line with an HTML document. When the web site is delivered from the back-end to the front-end, the PHP content is executed and added to the HTML to form one HTML document. The start of in-line PHP is denoted with <?php and the end is denoted with ?>.

As an example, consider the following code:

<p>This HTML will get delivered as is</p>
<?php echo "<p>But this code is interpreted by PHP and turned into HTML</p>";?>

In PHP, the echo keyword is used to output text. The text in this case is everything between the double quotes ("). An instruction written in PHP is called a statement. A semicolon (;) is required at the end of each statement in PHP.

So when the code above is executed, it outputs the text into the HTML file and the front-end will receive the following HTML document:

<p>This HTML will get delivered as is</p>
<p>But this code is interpreted by PHP and turned into HTML</p>

How is PHP Executed?

In the previous exercise, we explored how PHP can be sent from the back-end to the front-end where it is received as HTML to be displayed by a browser.

PHP is flexible and can also be executed from the terminal. We can use PHP as a general purpose programming language to write programs that give simple instructions to the computer without involving HTML or the web. When this is done, the output of the program is logged to the terminal. This is useful when testing functionality or for writing simple local programs.

When writing a PHP script file, we still need to denote that we are beginning our PHP code using <?php, but the closing tag is no longer required. It is typically left out by convention.

For example, if the following code were placed in index.php:

<?php
echo "Hello, World!";

When the code above is run, "Hello, World!" will be output to the terminal.

Generally, PHP ignores whitespace (tabs, spaces, new lines), so this code yields the same result as the previous example:

<?php
echo     "Hello, World!";

You may be surprised that this code also works:

<?php
Echo "Hello, World!";

Unlike many other languages, PHP is not always case-sensitive, so Echo is a valid statement in PHP. However, it’s best practice to use standard casing – in this case, echo.

PHP Comments

Sometimes, we want to include text in our files that we don’t want the computer to execute or display to the end user. We can do this with comments. Comments can be used to annotate our code to make it clearer to ourselves or others. They are also useful to prevent lines of code from being executed without deleting them.

In PHP, there are two main ways to add comments to our code. The first is single line comments. These are typically used for short explanations or points of clarification. Either # or // can be used to create a single line comment. Anything on the same line after these symbols is not executed by PHP.

For example:

// I will always remember this
echo "Hello world"; // My first PHP statement

or

# I will always remember this
echo "Hello, World!"; # My first PHP statement

The second type of comment is a multi-line comment. This is used for longer descriptions, a more detailed guide on how to properly use the section of code, or to prevent several lines of code from being executed. These comments are started with /* and ended with */.

For example:

/* "I've never thought of PHP as more 
than a simple tool to solve problems."
- Rasmus Lerdorf */
echo "Hello, World!";

Todo: Learn PHP

Before moving on, let’s take a quick look at a working PHP application.

We’re going to show you an example of PHP being used on the back-end to create a dynamic website sent to the browser. When the visitor to the website, in this case you, modifies the task list, a request is made for a new web page, the PHP code runs again in the back-end and delivers a new version of the site with updated HTML.

The todo list example is frequently used when demonstrating a web framework or technology. It provides a way to exhibit how the CRUD (Create, Read, Update, Delete) behaviors are implemented using a specific technology.

Within a todo app, the functionality is typically:

    Add new items to the list (Create)
    View the existing list (Read)
    Change the completion status of each item (Update)
    Remove items from the list (Delete)

Review

In the next lesson, you’ll start creating your own PHP code. Take a second and review what you already know about PHP:

    Despite its age, PHP is still a commonly used technology in web development.
    PHP is designed to interact with HTML to generate dynamic websites.
    Embedding PHP in HTML is done by placing PHP code between <?php and ?> tags.
    Every statement in PHP must be terminated with a semicolon ;.
    PHP files have a .php extension and the file always starts with the opening PHP tag <?php. The closing tag is implied and left out by convention.
    Whitespace is generally ignored when executing PHP code.
    Keywords are not case sensitive in PHP. As a convention, use the standard casing.
    Single line comments are made in PHP using # or //. Multi-line comments are placed between /* and */.

Strings

illustration of string

In everyday conversation, we use the word data to refer to any sort of information. This information is often a list of numbers, like a company’s monthly expenses or statistics about an athlete’s performance. However, in programming, data means something very specific. It’s still information, but that information takes the form of a few specific types.

The PHP language has different ways of handling different types of data. Which actions the computer can perform and how the computer stores the data in memory will vary based on the type. In this lesson, we’ll be learning about the string data type.

Strings are words or pieces of text that the computer treats as a single item. A string is a sequence of characters. It can be any length and contain any letters, numbers, symbols, or spaces surrounded by quotation marks.

echo "My first string"; // Prints: My first string

It’s important to distinguish between strings and the rest of the code in a PHP program. Every part of a program is text, but strings are the parts we intend to keep as data—not as instructions to be executed by computer. In this lesson we’re going to focus on strings wrapped in double quotation marks (if you’re curious, you can check out the official PHP documentation to see other types of PHP strings).

In later lessons, we’ll be using PHP to create custom HTML documents enabling dynamic web pages. As we learn the basics, however, we’ll be writing simple PHP only programs that run in the terminal.

Let’s make some strings!
Instructions
1.

Let’s start with the classic. Use the echo keyword to print Hello, World!.

You should always end a PHP statement with a semicolon.

<?php
// Write your code below:
echo "Hello, World!";  
  
  
  Escape Sequences

We use quotation marks to indicate the start and end of a string. The quotation marks tell the computer that we want everything inside them to be treated as a single piece of data. But how do we include quotation marks inside a string?

Consider the following string: "She said "hi" to the dog."

In the code above, the quotes around “hi” are intended to be part of the string, but the computer will actually see two strings "She said " and " to the dog." with hi in between. Since hi won’t be recognized as valid PHP it will result in an error:

echo "She said "hi" to the dog."; //syntax error, unexpected 'hi' (T_STRING)

In order to indicate which quotation marks the computer should view as instructions vs which it should view as simply characters, PHP allows for escape sequences. An escape sequence usually consists of a backslash (\) immediately followed by another character.

echo "She said \"hi\" to the dog."; // Prints: She said "hi" to the dog.

Quotation marks aren’t the only symbol requiring an escape sequence. When we print multiple strings, PHP will print them to the same line by default:

echo "1. Go to gym";
echo "2. Cook dinner"; 

The code above will output 1. Go to gym2. Cook dinner. To print the second string on a new line, we can use the newline escape sequence (\n):

echo "1. Go to gym";
echo "\n2. Cook dinner"; 
/* Prints
1. Go to gym
2. Cook dinner
*/

You don’t need to worry about other escape sequences yet, but if you’d like to see the full list you can find one in the PHP documentation.

Let’s practice!
1.

Let’s make a to-do list for you. Use echo to print a string to the console in the following format: 1. [thing you have to do]. For example, here’s ours: 1. Teach PHP.
2.

Let’s create a new echo statement for the next item on our to-do list.

By default, this second statement would print on the same line as the first… Start this second string with the escape sequence for a new line character. Next, continue the string in the same format as before: 2. [Another thing to do].
3.

Let’s throw a third thing on the list. This time, let’s mix it up. Include something inside your string wrapped in double quotes. For example, here’s ours 3. Learn to have "fun".

<?php
// Write your code below:
  echo "1. Do stuff";
  echo "\n2. Drink water";
  echo "\n3. Learn to have \"fun\"";
  
  String Concatenation

It can be useful to combine two strings together. This process is called string concatenation, and we can use the concatenation operator (.) to do this.

An operator is a character that performs a task in our code. The computer will take the string to the left of the concatenation operator, combine it with the string to the right, and return the resulting single string. Let’s see an example of string concatenation:

echo "one" . "two"; // Prints: onetwo

Notice how the string “onetwo” was printed. The computer won’t make any assumptions for us—it will combine the strings exactly as they are without adding any spaces or line-breaks. If we want spaces, we’ll have to add any spaces we want ourselves. Here we added a space to the string "one ":

echo "one " . "two"; // Prints: one two

We can also combine, or chain, our operations to get a final result:

echo "one" . " " . "two" . " " . "three"; // Prints: one two three

The concatenation operator takes two strings (the operands) and produces a string as a result (the return value). As we delve deeper into PHP, we’ll learn about other kinds of operators. Most will take one or two operands, but there’s even one that takes three.

Let’s join some strings together!

Instructions
1.

Use echo to print the string "Code" concatenated to the string "cademy".
2.

We want to learn a little more about you. Uncomment the line of code that starts with echo "\nMy name is:" and concatenate the given string with a string containing your name. Include a space after the colon without editing the string we provided.
3.

Use echo to print a final portmanteau by concatenating these four strings "\n", "tur", "duck", and "en". Make sure to include a semicolon after the statement.


<?php
// Write your code below:   
echo "Code"."cademy";

echo "\nMy name is:". " "."Tatiana"; 
  
echo "\n"."tur"."duck"."en";

 
Variables

Let’s say I have a really long string in my program, and I’m going to need to use it multiple times. Do I have to type the string out every time I need to use it? The answer is “no”. Variables are a fundamental programming concept designed to address this concern. With variables, we store values so that we can easily reuse them throughout a program.

Before we can use variables in our code, we need to declare and assign them.

Declaring a variable is the process of reserving a word, the variable name, which we’ll be able to refer to in our code. It’s good practice to name the variable in a way that describes the data it holds.

Assignment is the process of associating that variable name with a specific value so that everytime we use the variable’s name the computer will grab that value.

gif of assigning a variable

Creating Variables

Let’s look at an example of creating a variable:

$my_name = "Aisle Nevertell";

In the code above, we’re actually doing two things with a single statement: we’re declaring a new variable by giving it the name my_name. We’re also assigning it the value "Aisle Nevertell". The variable $my_name now holds the value "Aisle Nevertell".

To declare a variable we use the dollar sign character ($) followed by our chosen variable name. The dollar sign is known as a sigil; it’s a character that allows the computer to see quickly that something is a variable.

To assign it a value we use another operator: the assignment operator (=) followed by the value we’re assigning to the variable.

Though it can occasionally be useful to separate these actions, we’ll most often be declaring and assigning variables at the same time.

syntax diagram

In PHP, variables names can contain numbers, letters, and underscores (_), but they have to start with either a letter or an underscore. Variable names are case sensitive, meaning that PHP will treat the variables $my_example and $My_example as two different variables.

One common convention when naming PHP variables is to use an underscore between words on variable names with more than one word in their name. This is known as snake case:

$mood = ":)";
$favorite_food = "Red curry with eggplant";

Let’s create some variables!

Instructions
1.

Create a variable and assign to it a string value. You can give the variable any valid name you’d like and assign a string containing anything you want. End the statement with a semicolon.
2.

Declare a variable $biography and assign to it a string that starts with a new line character and contains a sentence or two about you.
3.

Create a variable $favorite_food and assign to it the string "\n", "tur", "duck", and "en" concatenated together.

<?php
// Write your code below:

$weather = "snowy";
$biography = "\nI'm learning to code while caring about a child.";  
$favorite_food = "\n" . "tur" . "duck" . "en";  
  
  Using Variables

Once we’ve declared a variable and assigned a value to it, we can use it as many times as we want. We refer to a variable by using the dollar sign followed by the variable’s name.

$favorite_food = "Red curry with eggplant, green beans, and peanuts";
echo $favorite_food; 
// Prints: Red curry with eggplant, green beans, and peanuts

Except during assignment, whenever the computer sees a variable in your code, it replaces the variable with the value assigned to that variable.

$dog_name = "Tadpole";
echo $dog_name; 
// Prints: Tadpole

Since the computer treats a variable just as if it were the value it holds, this means we can do operations on variables just as we would with any value of that type.

$dog_name = "Tadpole";
echo "My dog is named " . $dog_name; 
// Prints: My dog is named Tadpole

In the code above, we concatenated the string "My dog is named " to the value held by the $dog_name variable ("Tadpole"). Let’s look at another example that uses multiple variables:

$dog_name = "Tadpole";
$favorite_food = "salmon";
$color = "brown";

echo "I have a " . $color . " dog named " . $dog_name . " and her favorite food is " . $favorite_food . ".";
// Prints: I have a brown dog named Tadpole and her favorite food is salmon.

Let’s use some variables!
Instructions
1.

You’re going to create a couple variables. The variable, $name, should be assigned your name as a string. The second,$language, should be assigned a string value representing a language you’re learning.
2.

Use echo to print any string you’d like with the $name variable concatenated to it.
3.

Use echo to print a string starting with a newline (\n) with $language variable concatenated to it.

<?php
// Write your code below:
  
$name = "Tatiana";
$language = "PHP";
  
echo "My name is ".$name;  
echo "\nI'm here to learn ".$language;

Variable Parsing

In the last exercise, we saw how concatenating a number of strings and string variables got annoying. There’s an easier way!

PHP strings allow us to place variables directly into double quoted strings. These variables will be parsed which means the computer will read the variables as the value they hold rather than see them as just a sequence of characters.

$dog_name = "Tadpole";
$favorite_food = "salmon";
$color = "brown";

echo "I have a $color dog named $dog_name and her favorite food is $favorite_food.";
// Prints: I have a brown dog named Tadpole and her favorite food is salmon.

PHP string parsing is incredibly useful. Whenever PHP sees a dollar sign ($) inside a string it will assume all the characters next to it (until it reaches a character that couldn’t be included in a variable name) are a part of the variable name.

Sometimes this can get complicated. Consider the following example:

$toy = "frisbee";
echo "Alex likes playing with $toys";

The code above will cause an error. Why? The computer was looking for a variable $toys and couldn’t find one.

Fear not! PHP allows us to specifically indicate the variable name by wrapping it in curly braces to avoid any confusion. We’ll include the dollar sign followed by the variable name wrapped in curly braces:

$dog_name = "Tadpole";
$favorite_food = "treat";
$color = "brown";

echo "I have a ${color}ish dog named $dog_name and her favorite food is ${favorite_food}s.";
// Prints: I have a brownish dog named Tadpole and her favorite food is treats.

Let’s have PHP do some variable parsing for us!
Instructions
1.

We’re going to write a silly sentence PHP program. There are a number of variables assigned the string ‘___’. Replace each of them with words of the designated type.
2.

Beneath the three variables, there’s an echo statement with three blanks (___) in it. Replace those blanks with the three variables (in the order they were declared).
3.

At the end of the program, there’s a commented out line of code. We commented it out because it wasn’t working properly. Fix the line of code and uncomment it.

<?php
// Fill in the blanks in the code below:
  $noun = "spring";
  $adjective = "warm";
  $verb = "shine";

  echo "The world's most beloved $noun was very $adjective and loved to $verb every single day.";


//Fix the code below and uncomment it:

echo "\nI have always been obsessed with ${noun}s. I'm ${adjective}ish. I'm always ${verb}ing.";

Variable Reassignment

The word variable comes from the latin variāre which means “to make changeable.” This is an apt name because the value assigned to a variable can change.

gif of reassignment

The process of assigning a new value to a variable is called reassignment. We reassign a variable using the assignment operator on a variable that’s already been declared:

$favorite_food = "Red curry with eggplant";
echo $favorite_food; // Prints: Red curry with eggplant

// Reassign the value of $favorite_food to a new string
$favorite_food = "Pizza"; 
echo $favorite_food; // Prints: Pizza

It’s often useful to create new variables assigned to the same value as an existing variable:

$first_player_rank = "Beginner";
$second_player_rank = $first_player_rank; 

In the code above, we declared the variable $first_player_rank and assigned to it the string "Beginner". Next, we declared $second_player_rank and assigned it to $first_player_rank.

This created a new variable ($second_player_rank) assigned the value "Beginner". Notice how variables can be treated different depending on where they appear in code. During variable assignment or reassignment, the variable on the left of the assignment operator is treated as a variable (named storage for holding a value) while a variable on the right of the operator is treated as the value it stores. 

Instructions
1.

We declared a variable $movie and assigned the string "___" to it. But that’s no fun! Beneath that declaration, reassign $movie so that it’s assigned a string containing your favorite movie from when you were a little kid.
2.

Below your reassignment of the $movie variable, declare and assign a new variable, $old_favorite. The $old_favorite variable should have $movie assigned to it.
3.

Between the first and second echo statements, reassign the value of $movie to a new string.
4.

Finally, at the end of the program add one last echo statement which uses PHP string parsing to print a string containing the $old_favorite variable.

<?php
  $movie = "___";
// Add your code here:

$movie = "Terminator";

  echo "I'm a fickle person, my favorite movie used to be $movie.";
  
// Add a statement here:
$old_favorite = $movie;  
$movie = "Agirre";  
  echo "\nBut now my favorite is $movie.";
  
// Add a statement below:
echo "I loved $old_favorite when I was a kid.";

Concatenating Assignment Operator

We can assign and reassign variables to the values that result from operations:

$full_name = "Aisle" . " Nevertell";
echo $full_name; // Prints: Aisle Nevertell

During assignment, the computer will first evaluate everything to the right of the assignment operator and return a single value.

In the code above, the computer will concatenate the strings "Aisle" and " Nevertell" into the value "Aisle Nevertell". It will then assign this string as the value to the $full_name variable.

This is true even for more complex operations:

$full_name = "Aisle" . " " . "Nevertell" . " " . "Nomaderwat";
echo $full_name; // Prints: Aisle Nevertell Nomaderwat

One theme you may notice as you learn a programming language’s syntax is that common actions that programmers need to do a lot often have a shortcut. Consider the following:

$full_name = "Aisle";
$full_name = $full_name . " Nevertell";
echo $full_name; // Prints: Aisle Nevertell

In the code above, we have the variable $full_name assigned the value "Aisle". We want to reassign $full_name to its current value appended with the string " Nevertell".

Believe it or not, this is such a common task that PHP offers a shorthand notation, the concatenating assignment operator (.=). Let’s compare the same action but using this alternate operator:

$full_name = "Aisle";
$full_name .= " Nevertell";
echo $full_name; // Prints: Aisle Nevertell

It may seem funny to provide a shortcut to save just a few characters of typing, but when operations are performed often enough, those keystrokes can really add up. This syntax is also faster and easier to read which makes code easier to maintain.

One important thing to note is that even though PHP is often flexible about whitespace, it is inflexible with the concatenating assignment operator—the . and = characters must not have any spaces or other whitespace characters between them.

Let’s practice!

Instructions
1.

We’re going on a picnic. We started you off with the $sentence variable holding the value "\nI'm going on a picnic, and I'm taking apples".

Use the concatenating assignment operator (.=) to add another item to our list. The string you append should start with a comma(,) and a space followed by a word which starts with the letter “b”.

Next use echo to print the new value of $sentence.
2.

That was fun. Let’s keep playing.

This time use the concatenating assignment operator (.=) to append a string which starts with a comma(,) and a space followed by a word which starts with the letter “c”.

Use echo to print the newest value of $sentence.

<?php
  echo "I'm going on a picnic!";

  $sentence = "\nI'm going on a picnic, and I'm taking apples";

  echo $sentence;

// Write your code below:
$sentence .= ", bananas";

echo $sentence;

$sentence .= ", carrots";

echo $sentence;

Assign by Reference

When we create a variable assigned to another variable, the computer finds a new space in memory which it associates with the left operand, and it stores a copy of the right operand’s value there.

GIF of assigning by value

This new variable holds a copy of the value held by the original variable, but it’s an independent entity; changes made to either variable won’t affect the other:

$first_player_rank = "Beginner"; 
$second_player_rank = $first_player_rank; 
echo $second_player_rank; // Prints: Beginner

$first_player_rank = "Intermediate"; // Reassign the value of $first_player_rank
echo $second_player_rank; // Still Prints: Beginner

We can also create an alias, or nickname, for a variable. Instead of a copy of the original variable’s value, we create a new name which points to the same spot in memory.

GIF of assigning by reference

We use a different operator for this—the reference assignment operator (=&).

When we assign by reference we’re saying that the variable on the left of the operator should point, or refer, to the exact same data as the variable on the right. With assignment by reference, changes made to one variable will affect the other:

$first_player_rank = "Beginner";
$second_player_rank =& $first_player_rank; 
echo $second_player_rank; // Prints: Beginner

$first_player_rank = "Intermediate"; // Reassign the value of $first_player_rank
echo $second_player_rank; // Prints: Intermediate

Ok, let’s get some practice!

Instructions
1.

You’ve inherited some code from another developer. You can’t change their code, but you need to add some additional functionality. Instead of using the $very_bad_unclear_name variable as is in your part of the code. Declare a new variable, $order, as a reference to the $very_bad_unclear_name variable.
2.

Use the concatenation assignment operator to append more things to $order.

Awesome! Notice how when we echo the $very_bad_unclear_name variable at the end of the programs, the changes you made are reflected in the output!

<?php
/* Imagine a lot of code here */  
  $very_bad_unclear_name = "15 chicken wings";

// Write your code here:

$order =& $very_bad_unclear_name;

$order .= " and a large soda";

    
  // Don't change the line below
  echo "\nYour order is: $very_bad_unclear_name.";

PHP Strings and Variables
Review

Awesome work! We’ve covered a lot of material in this lesson, so let’s review:

    Strings are collections of text that the computer treats as a single piece of data.
    A string can be any length and contain any letters, numbers, symbols, or spaces surrounded by quotation marks.
    In order to include certain characters inside strings we have to use escape sequences.
    An operator is a character that performs a task in our code.
    We can use the concatenation operator (.) to combine two strings into one.
    Variables are a fundamental programming concept which allow us to easily reuse data in our code.
    We declare a variable using the dollar sign ($) followed by the variable name and then use the assignment operator (=) to give it a value.
    PHP has variable parsing which allows us to include variables directly in our strings.
    Once a variable has been assigned, we can change its value. This is called reassignment.
    We can create an alias for a variable, instead of just a copy, using the reference assignment operator (=&).
    Operations to the right of the assignment operator will be evaluated before assignment takes place.
    The concatenating assignment operator (.=) is a shorthand notation for reassigning a string variable to its current value appended with another string value.

If that was a lot to take in, don’t worry about memorizing everything right away. Remember that when you want to explore more about the language, the documentation is a great place to get comfortable exploring.

PHP Numbers
Numbers

Numbers and arithmetic operations are a fundamental part of programming. In this lesson, we’ll learn how to use and manipulate numbers in PHP.

PHP has two number data types. The integer data type includes positive and negative whole numbers (such as 3, 4599, -98, and 0). The floating point data type is used to represent decimal numbers (such as 4.98273, 2.1, -9.7, -182736.8).

echo 5; // Prints: 5
echo -22.8; // Prints: -22.8

We can also declare variables and assign numbers as their values:

$my_int = 78;
$my_float = -897.21;

echo $my_int; // Prints: 78
echo $my_float; // Prints: -897.21

In the code above, we created the $my_int variable and assigned the integer value of 78 to it. Next, we created the $my_float variable and assigned the floating point value of -897.21 to it.

Let’s practice making number variables!

Instructions
1.

Declare a variable with any name you’d like and assign an integer value to it. Use echo to print your variable to the terminal.
2.

We’re going to make and print another number variable, but we don’t want it to print on the same line. Use echo to print the string "\n".

Next, declare a variable with any name you’d like and assign a floating point value to it. Use echo to print this new variable to the terminal.
<?php
// Write your code below:
  
$int = 4;
echo $int;

echo "\n";
$float = 14.88;

echo $float;

Addition and Subtraction

PHP provides several operators we can use on numbers. Let’s start with two that are likely familiar: the addition (+) and subtraction (-) operators:

echo 5 + 1; // Prints: 6
echo 6.6 + 1.2; // Prints: 7.8
echo 198263 - 263;  // Prints: 198000
echo -22.8 - 19.1; // Prints: -41.9

Most of the time, we don’t have to worry about which type of number we’re using. We can add a float to an integer, subtract an integer from a float, and so on.

One quirk is that operators will return integers whenever the result of the operation evaluates to a whole number. So 8.9 + 1.1 will return 10, an integer, and not 10.0 even though both of the operands in the calculation were floating point numbers.

Let’s do some adding and subtracting!

1.

Use echo to print the number 12 to the terminal. The trick: use addition or subtraction to print a statement that evaluates to 12, and the number 12 can’t appear anywhere in your code!

<?php
// Write your code below:
echo 10+2;  
  
  Using Number Variables

We can use number operators on variables that hold number values:

$tadpole_age = 7;
$lily_age = 6; 
$age_difference = $tadpole_age - $lily_age;
echo $age_difference; // Prints 1

Let’s look at another example of performing operations with number variables:

$favorite_num = 22;
echo $favorite_num + 1; // Prints 23
echo $favorite_num; //Prints 22

In the code above, we created the variable $favorite_num then we used echo to print that value plus 1. Note that we didn’t reassign the value of the $favorite_num variable, so it still had the value 22 when we printed it on the last line.

We reassign number variables using the assignment operator:

$age = 82;
echo $age; // Prints: 82

$age = $age + 2;
echo $age; // Prints: 84

Let’s do some addition and subtraction with variables!

Instructions
1.

Can you help? I’m trying to figure out how much more I spent last month than this month. Last month I spent 1187.23 and this month I spent 1089.98. Create the variables $last_month and $this_month and assign them the corresponding numeric values.
2.

Use echo to print the difference between last month’s spending and this month’s.
<?php
// Write your code below:
$last_month = 1187.23;
$this_month = 1089.98;
  
echo $last_month - $this_month;
  
Multiplication and Division

PHP also gives us operators for performing multiplication (*) and division (/).

echo 2 * 3; // Prints: 6
echo -21 / 7; // Prints: -3

Like with addition and subtraction, when we perform multiplication or division, the computer will return an integer whenever the operation evaluates to a whole number.

The reverse is also true:

$num_cookies = 24;
$num_friends = 7;
$cookies_per_friend = $num_cookies / $num_friends;
echo $cookies_per_friend; // Prints: 3.4285714285714

In the code above, we performed an operation on two integers that didn’t divide into each other evenly, so the computer returned a floating point number.

Let’s multiply and divide!
Instructions
1.

Meg is trying to figure out how long, on average it takes her to learn a programming language. So far, she knows Ruby, Python, JavaScript, and C++. Create a variable, $num_languages, and assign to it the number of programming languages she has learned. Create a second variable, $months and assign 11 to it, which is the number of months she’s spent learning how to code.
2.

Let’s get more precise. Meg realizes that she hasn’t quite studied every day. Create a variable $days and assign as its value the result of multiplying $months by the number of days per month she thinks she actually spent studying, which is 16 days each month.
3.

Let’s figure out, on average, how many days it took her to learn each language. Assign the result of of this operation to a variable $days_per_language.
4.

Print your $days_per_language variable to the terminal.
<?php
// Write your code below:
  
$num_languages = 4;
$months = 11;
  
$days = 16*$months;  

$days_per_language = $days/$num_languages;

echo $days_per_language;

PHP give us an operator for raising a number to the power of another number: the exponentiation operator (**).

For example, we can square a number by raising it to the power of 2:

echo 4 ** 2; // Prints: 16

We can also use this operator on floats and negative numbers:

echo 2.89 ** 3.2;  // Prints: 29.845104015297
echo 10 ** -1; // Prints: 0.1

For PHP to interpret this operator correctly it can’t have any spaces between the two * characters:

echo 2 * * 3; // Will result in an error

Let’s do some more math!

Instructions
1.

Use echo and the exponent operator to print the value of 8 squared to the terminal.
<?php
// Write your code below:
  
echo 8**2;  
  
  
Modulo

PHP also provides an operator that might be less familiar: modulo (%). The modulo operator returns the remainder after the left operand is divided by the right operand.

echo 7 % 3; // Prints: 1

In the code above, 7 % 3 returns 1. Why? We’re trying to fit 3 into 7 as many times as we can. 3 fits into 7 at most twice. What’s left over—the remainder—is 1, since 7 minus 6 is 1.

gif of modulo operation

The modulo operator will convert its operands to integers before performing the operation. This means 7.9 % 3.8 will perform the same calculation as 7 % 3—both operations will return 1.

Let’s look at another example of the modulo operator in action:

$num_cookies = 27;
$cookies_per_serving = 4;
$leftover_cookies = $num_cookies % $cookies_per_serving;
echo $leftover_cookies; // Prints: 3

Let’s practice using modulo!

1.

We have 82 students going on a class trip. We want to divide the students into groups of 6. Use the modulo operator to echo how many students will be left without groups.
<?php
// Write your code below:
  
echo 82%6;  
  
  

Order of Operations

We can chain multiple operations together to get a single result:

echo 2 + 3 + 4 + 5 - 1.1; // Prints: 12.9
echo 2 * 9 / 6; // Prints: 3

You might have learned about operations having an order of precedence in a math class. This means that operations in a chain aren’t simply performed from left to right; rather each operator is given a special rank.

Operations will be evaluated in the following order:

    Any operation wrapped in parentheses (())
    Exponents (**)
    Multiplication (*) and division (/)
    Addition (+) and subtraction (-).

The acronym PEMDAS can be helpful for remembering the order of precedence for these arithmetic operations.

echo 1 + 3 * 9; // Prints: 28

In the example above, 3 * 9 (27) is calculated first and then is added to 1 to yield a final result of 28. We can change what this expression returns by using parentheses:

echo (1 + 3) * 9; // Prints: 36

Here, 1 + 3 (4) is calculated first and then that value is multiplied by 9 to which returns 36.

Let’s practice writing some chained operations!
Heya! Can you help me out. Use echo to print the answer to the terminal.

I’m trying to figure out how much money I should have. At the start of the day I had $94.

    I spent $4.25 on coffee
    A friend gave me $7 that he owed me
    I went out for a meal. The bill was $23.50, but I also gave a 20% tip.
    Some friends and I found $20 on the ground and split it four ways

I think that’s everything.

Use a single chained operation to get your result!
<?php
// Write your code below:
  
echo 94 - 4.25 + 7 - (23.5 + 23.5 * 0.2) + 20/4;  
  Mathematical Assignment Operators

One common task when manipulating number variables is to reassign them to their old value with some operation performed on it.

$savings = 800;
$bike_cost = 75;
$savings = $savings - $bike_cost;
echo $savings; // Prints: 725

This is such a common task that PHP provides a shorter syntax using arithmetic assignment operators:
Operation: 	Long Syntax: 	Short Syntax:
Add 	$x = $x + $y 	$x += $y
Subtract 	$x = $x - $y 	$x -= $y
Multiply 	$x = $x * $y 	$x *= $y
Divide 	$x = $x / $y 	$x /= $y
Mod 	$x = $x % $y 	$x %= $y

We could use this shorter syntax to rewrite the above code:

$savings = 800;
$bike_cost = 75;
$savings -= $bike_cost;
echo $savings; // Prints: 725

With mathematical assignment operators, PHP doesn’t allow spaces between the two characters.

Ready for one more shortcut? Increment operators allow us to subtract or add one to a number with just two characters.

$age = 89; 
$age++;
echo $age; // Prints: 90

$days_til_vacation = 7; 
$days_til_vacation--;
echo $days_til_vacation; // Prints: 6

In the code above, we used the post-increment (++) operator to add one to $age and we used the post-decrement operator (--) to subtract one from $days_til_vacation.

Those keystrokes can add up, so let’s practice using arithmetic assignment operators on variables!
1.

We’re going to do a mathematical “magic” trick. Create a variable, $my_num and assign as its value any number.

Next, create a second variable, $answer and assign $my_num as its value.
2.

Use the addition assignment operator to add 2 to $answer.
3.

Use the multiplication assignment operator to multiply $answer by 2.
4.

Use the subtraction assignment operator to subtract 2 from $answer.
5.

Use the division assignment operator to divide $answer by 2.
6.

Almost there. Use the subtraction assignment operator to subtract your original number ($my_num) from $answer. Finally, use echo to print $answer to the terminal.

If everything went as it should, $answer should be 1. No matter what your original number was! Don’t believe us? Go ahead try it with a different number for the value of $my_num.
<?php
// Write your code below:
$my_num = 7;
$answer = $my_num;
  
$answer += 2;  
  
$answer *= 2;  
  
$answer -= 2;  
  
$answer /= 2;  
  
$answer -= $my_num;

echo $answer;
  
  Review

Great job! In this lesson, we learned all about using numbers in PHP. Let’s review what we covered:

    PHP has two number data types: integers and floating point numbers
    We can use arithmetic operators for performing math operations:

Operation: 		Example:
Addition 	+ 	echo 1 + 4.5; // Prints: 5.5
Subtraction 	- 	echo 9 - 1; // Prints: 8
Multiplication 	* 	echo -1.9 * 2.9; // Prints: -5.51
Division 	/ 	echo 9 / 1; // Prints: 9
Modulo 	% 	echo 11 % 3; // Prints: 2
Exponentiation 	** 	echo 8**2; // Prints: 64

    Operations have an order of precedence meaning that certain types of operations in a chain will be evaluated before others: first evaluated will be any operation wrapped in parenthesis (()), next exponents (**), then multiplication (*) and division (/), and finally addition (+) and subtraction (-). The acronym PEMDAS can be a helpful way of remembering the order.
    We can assign number values to variables and then perform numerical operations with them.
    We can use mathematical assignment operators as a shorthand when reassigning number variables:

Operation: 	Long Syntax: 	Short Syntax:
Add 	$x = $x + $y 	$x += $y
Subtract 	$x = $x - $y 	$x -= $y
Multiply 	$x = $x * $y 	$x *= $y
Divide 	$x = $x / $y 	$x /= $y
Mod 	$x = $x % $y 	$x %= $y

Introduction to PHP Functions
Introduction

We can think of programs as series of instructions to be performed by the computer. So far in each of our PHP programs, each step has been explicitly laid out in the order we want it to happen.

Sometimes we’ll have a group of actions we want to repeat in a program. In these situations, we could copy and paste the lines of code we want to run again, but this isn’t very efficient. Instead, we should use functions.

A function is a set of instructions we package as a unit, often with a name, so that we can reuse it. We define a function by writing out the series of steps that should happen whenever we use the function. To use the function we call or invoke it.

In this lesson, we’re going to start learning the syntax for defining and invoking PHP functions. We’ll start with simpler functions and work our way to more complex ones. If this is your first time working with functions, it can feel like a big jump. Take your time and be patient with yourself.
Instructions

Take a look at the video—it shows how much simpler we can make a recipe by providing a single word to represent a set of instructions, eg. “chop”.

Defining Functions

Let’s get right to it and create our first function:

function greetLearner()
{
  echo "Hello, Learner!\n";
  echo "I hope you're enjoying PHP!\n";
  echo "Love, Codecademy";
}

Let’s walk through the code above:

    We used the function keyword to start our function definition.
    We named the function greetLearner. Function names must start with a letter or underscore, followed by any number of letters, numbers, or underscores.
    We created a code block with curly brackets ({ }). The code inside this code block will execute when our function is invoked.
    Within that block we wrote three instructions: echo "Hello, Learner!\n!";, echo "I hope you're enjoying PHP!\n";, and echo "Love, Codecademy";

With our greetLearner() function defined, we’ll be able to invoke the function multiple times and print those strings without having to copy or retype the three echo statements again and again.

A few notes on naming conventions: we typically snake case (separate words with underscores) our variable names, but, in order to easily tell the difference between variables and functions in our code, we’ll do something different when naming functions. We’re going to use camel case for our function names—we’ll start with a lowercase letter and then capitalize the first letter of every new word: camelCase vs. snake_case. Another good practice is to name functions in a way that describes what they do—typically we’ll start function names with a verb.

In the next exercise, we’ll show you how to invoke a function. For now, let’s get some practice defining them!
Instructions
1.

Define a function named praisePHP. You can leave the function body blank for now.
2.

Add at least one echo statement inside your function body which prints a string praising the PHP language.
3.

Now that your function is fully defined, run your program. Notice what happens… or really what doesn’t happen.
<?php
// Write your code below:
  
 function praisePHP() {
  echo "Hereby I praise PHP";
} 
  
  
  Invoking Functions

In our last exercise, we saw that when we define a function, the instructions within the code block aren’t executed. Defining a function only tells the computer to associate a name with a set of instructions. To actually execute this code we’ll need in invoke, or call, the function. Invoking a function is the process of using a function that’s been defined. Let’s look at an example:

function greetLearner()
{
  echo "Hello, Learner!\n";
  echo "I hope you're enjoying PHP!\n";
  echo "Love, Codecademy";
}

greetLearner(); 
/*
Prints:
Hello, Learner!
I hope you're enjoying PHP!
Love, Codecademy
*/

Below the definition of our greetLearner function, we invoked the function by writing its name followed by an opening and closing parenthesis (( )). This tells the computer to grab the instructions specified in the function definition and execute them.

When referring to functions outside of code or in comments, it’s conventional to refer to them by their name followed by parentheses (eg. greetLearner()), so we’ll be doing this from now on.

Let’s define and invoke some functions!
Instructions
1.

Define the function inflateEgo() which prints a compliment.
2.

Invoke your function!
3.

Just for kicks, edit your code so your function is invoked twice!
<?php
// Write your code below:
  function inflateEgo() {
  echo "U r breathtaking!";
}

inflateEgo();
inflateEgo();

Return Statements

As we build more complicated functions, we’ll often be using them to process data. In order for the data to be useful, functions have the ability to return a value in addition to performing instructions. Let’s look at an example:

function countdown() 
{
  echo "4, 3, 2, 1, ";
  return "blastoff!";
}

When the countdown() function is invoked it will print 4, 3, 2, 1,, but what about the string "blastoff!"? This value will be returned. We have a lot of options for what to do with a returned value. For example, we could capture it in a variable:

$return_value = countdown(); // Prints: 4, 3, 2, 1, 
echo $return_value; // Prints: blastoff!

This example is a little silly, since we could have just printed the string within the function, but, as we continue to create more complicated functions, the ability to return a value will become extremely useful.

Let’s get some practice returning a value from a function!


Instructions
1.

Write a function printStringReturnNumber() which prints a string and returns a number value.
2.

Capture your function’s return value in a variable named $my_num.
3.

Use echo to print your $my_num variable.
<?php

// Write your code below:
function printStringReturnNumber() {
  echo "Some string\n";
  return 4;
}  

$my_num = printStringReturnNumber();
echo $my_num;

More on Return Statements

The return keyword immediately stops a function. This means that any code after a return won’t run.

Let’s compare two different functions: announceRunning() and announceRunning2(). The first of these is defined as follows:

function announceRunning()
{
  echo "The first function is running!\n";
  return "This is the return value of the first function.";
}

$first_result = announceRunning();
echo $first_result;

Let’s walk through the code above:

    We defined the function announceRunning().
    Next, we defined the variable $first_result and assigned as its value the result of invoking the announceRunning() function. This actually did two things. It executed the function causing "The first function is running!/n" to be printed. It also assigned "This is the return value of the first function." to $first_result.
    Finally, we printed $first_result.

That seemed to work as expected. In our terminal we saw:

The first function is running!
This is the return value of the first function.

Let’s contrast that to the following example:

function announceRunning2()
{
  return "This is the return value of the second function.";
  echo "P.S., I love you";
}

$second_result = announceRunning2();
echo $second_result;

In this example, the string "P.S., I love you" will never be printed! As soon as the return statement is reached, the function will end. So in the terminal, we’d see this output:

This is the return value of the second function.

Let’s use this new knowledge to fix some broken code!
Instructions
1.

Run the code to see its current output.
2.

The notFound() function should print the string "ERROR: Page not found!\n" and return 404. Fix the notFound() function so that it works as intended.
3.

Great work! The greetLearner() function also isn’t quite right… We’d like all three of those echo statements to execute and the function to return "<3". Help!
<?php

function notFound()
{
  echo "ERROR: Page not found!\n";
  return 404;
}

function greetLearner()
{
  echo "Hello, Learner!\n";
  echo "I hope you're (still) enjoying PHP!\n";
  echo "Love, Codecademy\n";
  return "<3";
}

// Don't change the code below:

$error = notFound(); 
$heart = greetLearner();

echo "I received a $error, but it's ok because I also received $heart.";
Return Values

The value returned from a function is just that—a value. This means it can be used in any manner we would normally use a value of that type. This can take some getting used to. Take a look at the following code:

function returnFive() 
{
  return 5;
}

echo returnFive(); // Prints: 5

In the code above we defined a silly function, returnFive(); all it does is return the number 5. Then we used echo to print the invoked function. The way that the computer executes functions and handles their returns can take getting used to, but it’s very similar to what we experienced with numbers and variables:

echo 5 + 3; // Prints: 8

$num = 5;

echo $num + 3; // Prints: 8

echo returnFive() + 3; // Prints: 8

A computer evaluates 5 + 3 to 8. In the same manner, when a computer encounters a function invocation, it will execute the code in the function’s body and then evaluate to the function’s returned value. We need to think of functions as both what they do (the instructions in their code block) and what they return.

Let’s invoke more functions!
Instructions
1.

Use echo to print the return values of each of the three provided functions in order. The challenge: you may not use more than one line of code or more than a single statement (use only one semicolon).

Note: You can add space, new line, or other characters in between the return values.
<?php
function first()
{
  return "You did it!\n";
}

function second()
{
  return "You're amazing!\n";
}

function third()
{
  return "You're a coding hero!\n";
}

// Write your code below:
echo first() . second() . third();

Returning NULL

What about functions without return statements? Any function without a return returns a special value NULL. NULL is a special data type that stands for the absence of a value.

function returnNothing() 
{
  echo "I'm running! I'm running!\n";
}

$result = returnNothing(); // Prints: I'm running! I'm running!

echo $result; // Nothing is printed

Let’s walk through the code above:

    We defined a function returnNothing()— the returnNothing() function prints "I'm running! I'm running!\n" but has no return statement.
    We defined the variable $result and assigned it the value returned when we invoke return_nothing().
    Since we invoked the function, I'm running! I'm running! is printed.
    Because the function does not have a return statement, the value assigned to $result is NULL
    Finally, we print the $result variable, but, since its value is NULL, nothing is printed.

Let’s play around with NULL!
Instructions
1.

Write a function createVacuum() which returns nothing.
2.

NULL can be really quirky. You don’t need to worry about the details now. But, just for fun, uncomment the line we provided at the bottom of the code. Predict what it will output to the terminal. When you have a guess, run the code to see.
<?php

// Write your code below:
function createVacuum() {
  
}  

  
  
  
  
  
  
  
  
echo createVacuum() * 10;

Parameters

Functions that do exactly the same thing every time they run can save us from having to repeat code in our programs, but functions can do more.

In the beginning of this lesson, we wrote a greetLearner() function that printed the same friendly greeting every time it was invoked. That’s ok… we guess… But what we’d really like is to print a customized greeting. We can accomplish this by using parameters!

When we define a function, we can also define parameters. A parameter is a variable which serves as a placeholder throughout the function’s code block. When the function is invoked, it’s invoked with a specific value. As the computer executes the function, it replaces each occurrence of the parameter with the value that was passed in. The actual value passed in is known as an argument.

Let’s look at an example:

function sayCustomHello($name)
{
echo "Hello, $name!";
};

sayCustomHello("Aisle Nevertell"); // Prints: Hello, Aisle Nevertell!

sayCustomHello("Codecademy learner"); // Prints: Hello, Codecademy Learner!

In the code above, we defined the sayCustomHello() function. It has a $name parameter. We invoked the function twice:

    The first time, we passed in "Aisle Nevertell" as the argument. During that invocation, the function assigned "Aisle Nevertell" to $name so Hello, Aisle Nevertell! was printed.
    The second time we invoked the function with the argument "Codecademy learner" so $name was assigned that value and Hello, Codecademy Learner! was printed.

Let’s get some parameter practice!


Instructions
1.

Write a function increaseEnthusiasm() which takes in a string parameter and returns that string appended with an exclamation mark.
2.

Use echo to print the result of invoking your increaseEnthusiasm() function with a string of your choice.

Instructions
1.

Write a function increaseEnthusiasm() which takes in a string parameter and returns that string appended with an exclamation mark.
2.

Use echo to print the result of invoking your increaseEnthusiasm() function with a string of your choice.
3.

Write a function repeatThreeTimes() which takes in a string parameter and returns that string repeated three times (without introducing characters which didn’t appear in the original string).
4.

Use echo to print the result of invoking your repeatThreeTimes() function with a string of your choice.
5.

Ready for a little trickiness? Use echo to print the result of invoking your increaseEnthusiasm() with the result of invoking repeatThreeTimes() as the argument passed into increaseEnthusiasm(). You can choose any string you like for the argument to repeatThreeTimes().
<?php
// Write your code below:
function increaseEnthusiasm($str_param)
{
  return $str_param . "!";
}

function repeatThreeTimes($str_param)
{
  return $str_param . $str_param . $str_param;
}  

echo increaseEnthusiasm("oh");

echo repeatThreeTimes("wow");

echo increaseEnthusiasm(repeatThreeTimes("hai"));

Multiple Parameters

We can also define functions with multiple parameters.

function divide($num_one, $num_two)
{
  return $num_one / $num_two;
};

In the function above, we defined the divide() function. It takes in two number arguments and returns the result of dividing the first parameter by the second. Let’s look at how we invoke this function:

echo divide(12, 3); // Prints: 4

echo divide(3, 12); // Prints: 0.25

In the code above:

    First, we printed the value returned from invoking our divide() function with 12 and 3 as arguments.
    Next, we printed the value returned from invoking our divide() function with 3 and 12.

Notice that the order we pass in the arguments decides which parameters they correspond to—the first argument we pass into divide() will be assigned to $num_one and the second argument to $num_two.

Invoking a function with fewer arguments than expected will result in an error:

function expectTwo($first, $second)
{
  return "whatever";
}

echo expectTwo("test"); // Will result in an error

Ok! Let’s make functions with multiple parameters!
Instructions
1.

Write a function calculateArea() that takes in two number arguments—representing the height and width of a rectangle—and returns the area of that rectangle.
2.

Use echo to print the result of invoking your calculateArea() function with two number arguments.
3.

Write a function calculateVolume() that takes in three number arguments—representing the height, width, and depth of a box—and returns the volume of that box.
4.

Use echo to print the result of invoking your calculateVolume() function with three number arguments.
<?php
// Write your code below:
function calculateArea($height, $width) {
  $area = $height*$width;
  return $area;
}

echo calculateArea(3, 4);

function calculateVolume($height, $width, $depth) {
  $volume = $height*$width*$depth;
  return $volume;
}

echo calculateVolume(3, 4, 5);

Default Parameters

Earlier we wrote a sayCustomHello() function which took in a $name and printed a custom greeting. If we tried to invoke this function without an argument, it would cause an error; the function is designed to run with one argument, and it won’t accept fewer.

function sayCustomHello($name)
{
  echo "Hello, $name!";
};

sayCustomHello(); // Causes an error!

We can be more flexible about parameters when defining our functions. We want to print "Hello, [name passed in]!" if an argument is provided, and "Hello, old chum!" only if no argument is passed in.

We can accomplish this by providing a default value for the $name parameter:

function greetFriend($name = "old chum")
{
  echo "Hello, $name!";
};

greetFriend("Marvin"); // Prints: Hello, Marvin!

greetFriend(); // Prints: Hello, old chum!

In the code above, we defined the greetFriend() function. It has a parameter $name with a default value of “old chum”. We invoked the function twice:

    The first time, we passed in "Marvin" as the argument. During that invocation, the function assigned "Marvin" to $name so Hello, Marvin! was printed.
    The second time we invoked the function with no argument. Therefore, the default value of "old chum" was assigned to $name and Hello, old chum! was printed.

Let’s practice defining functions with default parameters.

Instructions
1.

Write a function calculateTip() which takes a number representing the total cost of a meal as its first argument. It should also take a second, optional argument—an integer representing the percent tip desired (eg. 25 will indicate a 25% tip should be calculated). If no second argument is passed in, the function should default to a 20% tip. The function should return the new total—the previous total plus the calculated tip.

For example:

    calculateTip(100, 25) should return 125
    calculateTip(100) should return 120
    calculateTip(65, 15) should return 74.75

2.

Use echo to test your function with one and two arguments to make sure it works as expected in each case.
<?php
// Write your code below:
function calculateTip($cost, $tip = 20) {
  $total = $cost + $cost*$tip/100;
  return $total;
}

echo calculateTip(100, 25);
echo calculateTip(100);

Pass By Reference

We can invoke functions with variables or with values directly. When we invoke a function with a variable as its argument, it’s as if we’re assigning the value held by that variable to the function’s parameter. We assign a copy of the value held by the argument variable. The variable argument and the parameter are distinct entities; changes made inside the function to the parameter will not affect the variable that was passed in:

function addX ($param)
{
  $param = $param . "X";
  echo $param;
};
$word = "Hello";
addX($word); // Prints: HelloX
echo $word; // Prints: Hello

Let’s walk through the code above:

    We defined a function addX() which reassigns $param to its previous value appended with "X".
    We defined the variable $word and assigned it the value "Hello".
    We invoked addX() with $word as its argument.
    During the function invocation, $param was reassigned and the function printed "HelloX".
    When we printed $word after the function was invoked, it remained its original value: "Hello".

If we do want to make permanent changes to a variable within a function, we can prepend the parameter name with the reference sign (&). In this way, we assign the parameter to be an alias for the argument variable. Both will refer to the same spot in memory, and changes to the parameter within the function will permanently affect the argument variable.

function addXPermanently (&$param)
{
  $param = $param . "X";
  echo $param;
};
$word = "Hello";
addXPermanently($word); // Prints: HelloX
echo $word; // Prints: HelloX

In the addXPermanently() function we made $param a reference to the argument. When we invoked the function with $word the changes made to $param permanently affected the $word variable. Let’s practice!
Instructions
1.

Create a function convertToQuestion(). It should take a reference to a string variable as its argument. The function should prepend the string with "Do you think " and it should add a question mark (?) and new line character (\n) to the end of the string. So the string "no" would become "Do you think no?\n"

$example = "I'm nice";

convertToQuestion($example);

echo $example; // Should print: Do you think I'm nice?

2.

Great job! Let’s test your function to make sure it’s working properly. We’ve provided you with three variables $string_one, $string_two, and $string_three. Invoke your function three times—once with each of the three variables.
3.

At the bottom of your code, use echo to print each of the string variables to confirm that their value has been permanently changed.
<?php

$string_one = "you have teeth";
$string_two = "toads are nice";
$string_three = "brown is my favorite color";

// Write your code below:
function convertToQuestion(&$example) {
  $example = "Do you think $example?\n";
  return $example;
}

echo convertToQuestion($string_one);
echo convertToQuestion($string_two);
echo convertToQuestion($string_three);

echo $string_one;
echo $string_two;
echo $string_three;

Variable Scope

Passing arguments into a function and returning values is a clear way to define the interface between the function and the rest of the code. This is the preferred method of exchanging information within a program since it is straightforward to see the data a function depends on from the function parameter list.

Consider the following function. It returns a number of days left of feed depending on the number of chickens and the rate at which they consume it.

function calculateDaysLeft($feed_quantity, $number, $rate)
{
  $result = $feed_quantity / ($number * $rate);
  return $result;
}
echo calculateDaysLeft(300, 2, 30);

You can immediately see that this function depends on three pieces of information to provide an answer:

    $feed_quantity
    $number
    $rate

We also echo what is returned by the function, instead of a variable from inside the function. If we attempted to:

echo $result;

outside of the function, it would throw an error (Undefined variable). This is due to variable scope. Each function has its own local scope. This means that any variables defined within the function’s code block can only be accessed within the code block itself.

However, if many functions depend on the same piece of information, it can be beneficial to have a variable that can be accessed anywhere without being passed in. To do this, we have to use the global keyword to tell PHP to look in the global scope for the variable, instead of the local scope of the function.

$feed_quantity = 300;
function calculateDaysLeft($number, $rate)
{
  global $feed_quantity;
  $result = $feed_quantity / ($number * $rate);
  return $result;
}
echo calculateDaysLeft(2, 120);

When using this pattern, it becomes slightly more difficult to determine what information this function depends on. Make sure to consider this trade-off when implementing your own functions.

Note that the global keyword is not used when invoking functions. Once a function has been defined, it can be used within the same code block or even within other function code blocks. This code will print “This works!” to the console.

function first()
{
  echo "This works!\n";
}
function second()
{
  first();
}
second();

Instructions
1.

We’ve created a function that will create a formatted name for a coding lesson based on two arguments:

    $language - the name of the programming language being taught
    $concept - the name of the concept being taught

We want to restructure the code to use the global $language instead of having to pass it in every time.

Remove $language from the parameter list and rewrite the function to use the global $language instead.

Be sure to update the invocation of generateLessonName to use only a single parameter.
<?php

$language = "PHP";
$topic = "scope";

function generateLessonName($concept)
{
  global $language;
  return $language . ": " . $concept;
}

echo generateLessonName($topic);

Review

Great job! Let’s review what we covered in this lesson:

    We can package a set of instructions within a named function to reuse whenever we’d like.
    When we invoke a function, the computer will execute the function body, specified by the code block following the parameters list.
    Functions can return a value by using the return keyword otherwise they return NULL which means no value.
    We can store the return value of a function in a variable or use it any other way we’d use a value.
    We can define functions with parameters which are variables we can refer to throughout our function’s body.
    When invoking functions, the values that we give them are called arguments.
    Functions can have multiple parameters.
    The order in which the arguments are passed in decides which parameters they correspond to.
    You can make an argument optional by providing its corresponding parameter with a default value.
    If you prepend a parameter with the reference sign (&) that argument will be passed by reference.
    Variables within functions have local scope and can not be accessed from outside the function.
    Use the global keyword to use variables from the global scope within a function.

Introduction

If you’ve been paying attention so far, you might have picked up a theme in programming—shortcuts. Defining our own functions gives us an easier way to repeat similar code throughout a program. But some tasks are so common that the language comes with them by default.

PHP comes with a number of built-in functions. These functions—also known as internal functions— can be invoked without writing them ourselves. In this lesson, we’ll explore some useful built-in functions and empower you to discover new built-in functions yourself. This will quickly become an essential part of your developer toolkit!

Let’s get started.
Instructions

We’ve been using echo to print information to the console. echo is NOT a function (it’s a “language construct”). But, one little PHP quirk is that we can use it in a way that looks a lot like invoking a function—we can wrap an argument for echo in parentheses.

echo can also be used to print multiple string arguments, but unlike a function, for this feature to work we must NOT wrap them in parentheses. Take a look at the code editor; we’ve provided some examples of using echo with and without parentheses. If you’d like, uncomment the broken code to see the error it causes.
<?php
echo("This works!\n");

echo "This also works!\n";

//echo("This would NOT work", "\n");

echo "Buuuut!", " ", "This", " ", "does!", "\n";

Working with Variables

PHP includes useful built-in functions for getting information about variables. The gettype() function takes a variable as its argument and returns a string value representing the data type of the argument.

$name = "Aisle Nevertell";
$age = 1000000;

echo gettype($name); // Prints: string

echo gettype($age); // Prints: integer

Notice that we didn’t write a definition for the gettype() function ourselves—it’s built into PHP. Since the function is included within the language itself, we can just call it anywhere within our PHP code.

Let’s take a look at another built-in function! The var_dump() function also takes a variable argument. It prints details about the argument it receives.

var_dump($name); // Prints: string(15) "Aisle Nevertell"

var_dump($age); // Prints: int(1000000)

In the code above, we first used var_dump() to print information about the variable $name. string(15)—the variable’s type and length—were printed followed by the value held by the variable.

Next, we used var_dump() to print information about the variable $age. Here, the integer is printed within the parentheses.

As we learn more data types—especially increasingly complex data types—we’ll see how useful these two functions can be. For now, let’s practice using them with the types of data we know!
Instructions
1.

Using echo and the gettype() function, print the data types of the $first and $second variables.
2.

Let’s compare that to what var_dump() outputs. Use var_dump() to display information about the $first and $second variable. 
<?php
namespace Codecademy;

$first = "Welcome to the magical world of built-in functions.";
  
$second = 82137012983; 

//Write your code below:
echo gettype($first);
echo gettype($second);

echo var_dump($first);
echo var_dump($second);

String Functions

We can find PHP built-in functions to accomplish common tasks. Need to reverse a string? There’s a built-in function for that!

The strrev() function takes in a string as its argument and returns a string with all of the characters of the original string in reverse order.

Let’s see it in action:

echo strrev("Hello, World!"); // Prints: !dlroW ,olleH

Remember that we can use the values returned from functions directly (rather than saving them into variables). In the code above, we used echo to print the value returned from invoking the strrev() function with the string "Hello, World!" as its argument.

PHP also comes with built-in functions to change the capitalization of a string. We can use the strtolower() function to transform an argument string into all lowercase letters:

echo strtolower("HeLLo"); // Prints: hello

Built-in functions often have multiple parameters. The str_repeat() function takes a string as its first argument and a number as its second. It returns a string containing the argument string repeated the argument number of times.

echo str_repeat("hi", 10); // Prints: hihihihihihihihihihi 

In the above code we used echo to print the value returned from invoking str_repeat() with "hi" and 10 as its arguments—"hihihihihihihihihihi" .

Let’s practice!
Instructions
1.

Use echo and the strrev() function to print the following string reversed: ".pu ti peeK .taerg gniod er'uoY"
2.

Use echo and the strtolower() function to print the following string with all lowercase letters: "SOON, tHiS WILL Look NoRmAL."
3.

Use echo and the str_repeat() function to print the string "\nThere's no place like home.\n" three times.

<?php
namespace Codecademy;

// Write your code below:
echo strrev(".pu ti peeK .taerg gniod er'uoY");
echo strtolower("SOON, tHiS WILL Look NoRmAL.");
echo str_repeat("\nThere's no place like home.\n", 3);

Working with Substrings

A substring is a portion of a string. For example, "hello" is a substring of the string "Oh hello, how are you?" and "el" is a substring of the string "hello". Manipulating strings is very common in programming, and working with substrings is often necessary.

The substr_count() function returns the number of instances of a substring within a string. It takes two arguments, the string to search through—sometimes called the haystack— and the string to search for—sometimes called the needle.

$story = "I was like, \"Dude, like just tell me what you like think because like everyone else is like being totally honest, and like I just want to know what you like think.\" So like I don't know...";

echo substr_count($story, "like"); // Prints: 8

In the code above, we invoked the substr_count() function, passing in $story as the haystack and "like" as the needle. We used echo to print the returned result—8, which is the number of times the substring "like" appears in the $story string.

Let’s practice!

Instructions
1.

Use echo and the substr_count() function to print the number of times the word “really” appears in $essay_one.
2.

Use echo and the substr_count() function to print the number of times the word “obvious” appears in $essay_two.

Notice that substr_count() is not concerned with which characters come before or after the string it’s searching for—it will count both “obvious” and “obviously”.

<?php
namespace Codecademy;

$essay_one = "I really enjoyed the book. I thought the characters were really interesting. The plot of the novel was really engaging. I really felt the characters' emotions. They were really well-written. I really wish the ending had been different though.";
  
$essay_two = "Obviously this is a really good book. You obviously would not have made us read it if it wasn't. I felt like the ending was too obvious though. It was so obvious who did it right away. I think the thing with the light was obviously a metaphor for life. It would have been better if the characters were less obvious about their secrets.";  

// Write your code below:
echo substr_count($essay_one, "really");
echo substr_count($essay_two, "obvious");

Number Functions

Another common task in programming is working with numbers, so it shouldn’t surprise us that PHP comes with some handy built-in functions for working with numbers.

The abs() function returns the absolute value of its number argument:

echo abs(-10.99); // Prints: 10.99

echo abs(127); // Prints: 127

Another useful function is the round() function which returns the nearest integer to its number argument:

echo round(1.2); // Prints 1

echo round(1.5); //Prints 2

echo round(1298736.821763876); // Prints: 1298737

Let’s practice!
Instructions
1.

You’re going to write a function which uses the abs() built-in function within its definition.

Write a function called calculateDistance() that calculates the distance between two numbers. The function should return the same result for two arguments no matter what order they’re passed into the function.

Here are some examples of how the function should work:

    calculateDistance(-1, 4) should return 5
    calculateDistance(4, -1) should return 5
    calculateDistance(3, 7) should return 4
    calculateDistance(7, 3) should return 4

Once you’ve finished writing your function, you should run it to make sure it’s working how it should.

Check out the hint if you want some help on the strategy or a reminder about how to define your own functions.
2.

Awesome! This time you’re going to write a function which uses the round() function.

Write a function calculateTip() which takes a number representing the total cost of a meal as its argument.

Your function should calculate a new total with an 18% tip added and return that value rounded to the nearest integer.

You’re function must invoke the built-in round() function. For example:

    calculateTip(100) should return 118
    calculateTip(35) should return 41
    calculateTip(88.77) should return 105

<?php
namespace Codecademy;

// Write your code below:
function calculateDistance($num1, $num2) {
  $distance = abs($num1 - $num2);
  return $distance;
}

function calculateTip($total) {
  $total += 0.18 * $total;
  return round($total);
}

Generating Random Numbers

Generating random numbers may not seem obviously useful, but, as your programs become increasingly complicated, you’ll see this is actually a common task—for example to randomize data for testing.

The rand() function returns a random integer. We have some flexibility with how we invoke it. Invoking rand() with no arguments will return a number between 0 and the largest number our current environment will allow; this is a quirk of PHP. We can find out what this number is by invoking a different built-in function, getrandmax():

$max = getrandmax(); 

echo $max;

echo rand(); // Prints a number between 0 and $max

In the code above, we assigned the largest possible random integer to the $max variable by invoking the getrandmax() function.

Next, we used echo to print a random integer. This integer will be a number between 0 and $max.

Functions often have a strict definition which dictates exactly which arguments it expects to be called with and results in an error otherwise. The rand() function, however is somewhat flexible.

If we’d like more control over the random number we generate, we can invoke the rand() function with two integer arguments representing the smallest allowable random number and the largest allowable random number. Fun fact: the second argument provided can be larger than getrandmax(). These numbers are inclusive meaning the arguments we pass in could be generated by the function.

echo rand(1, 2); // Prints either 1 or 2

echo rand(5, 10); // Prints a number between 5 and 10 (inclusive!)

echo rand(1, 100); // Prints a number between 1 and 100 (inclusive!)

Ok let’s get random!


Instructions
1.

Use echo and getrandmax() to find out what the maximum random number is in this environment.
2.

Now that we know its bounds. Let’s see what we get when we invoke the rand() function.

Use echo to print an invocation of the rand() function.

It’s totally optional, but you might consider adding this line of code between your other echo statements so you can read the output more easily:

echo "\n";

3.

Ok! Let’s call rand() again. This time use echo and rand() to print a random number between 1 and 52 (both inclusive).
<?php
namespace Codecademy;

// Write your code below:
echo getrandmax();
echo "\n";
echo rand();
echo "\n";
echo rand(1, 52);

Documentation

In order to understand built-in functions we’ve never used before, we’ll want to get comfortable understanding how they are represented in the documentation. Documentation typically includes:

    The name of the function.
    The versions of the PHP language the function is available in.
    An overview of how the function works.
    Additional details on the parameters and return value.
    Examples of the function in use.
    User comments further explaining features of the function.

The description section can be confusing, so we’ll break that down.

Here’s the description for the abs() function:

abs ( mixed $number ) : number

Here we see the function name followed by parentheses. The parentheses contain information about the function’s parameter(s)—first the parameter’s type followed by its name. The parameter for abs() has the type mixed because there are multiple data types the function will accept (an integer or a float). The parameter for abs() is named $number. After the parentheses is a colon (:) followed by number; this is the data type the function will return.

A function that prints something but doesn’t return a value will have :void instead of a return type. Similarly, a function that doesn’t accept parameters will have void within its parentheses.

Let’s look at a more complicated example. Here’s the description for the substr_count() function:

substr_count ( string $haystack , string $needle [, int $offset = 0 [, int $length ]] ) : int

Earlier in this lesson, we invoked substr_count() with only the two string parameters ($haystack and $needle). But functions can have optional parameters. This means they’ll work with or without them. These parameters are wrapped in square brackets ([ ]) in the function’s description. An optional parameter may have a default value, this is the value that will be used if no argument is passed into the function. The default value is indicated with an equal sign (=).

The substr_count() function accepts two additional integer arguments—$offset and $length. $offset has a default value of 0. Take a look at the documentation and see if you can figure out what they do.

Let’s practice reading some function descriptions!


Instructions
1.

Here’s the description for the str_pad() built-in function:

str_pad ( string $input , int $pad_length [, string $pad_string = " " [, int $pad_type = STR_PAD_RIGHT ]] ) : string

In the code editor, we’ve provided four variables: $a, $b, $c, and $d. Your task is to invoke str_pad() with these four variables as its arguments so that it returns the string: *~**~**~*You did it!*~**~**~*. You’ll need to figure out which order to pass them in.

Use echo to print the result of invoking the function.

This task is designed to be a little challenging. Check out the documentation for more information, and take a look at the hint for more guidance.

Note: One of the arguments (and its corresponding variable) is a PHP type we haven’t taught yet: pre-defined constants. You can solve this challenge without understanding them deeply. Predefined constants are similar to variables—they’re names which hold values. Unlike variables, predefined constants are defined by the language, not by us, and they’re constant, they can’t change value.


<?php
namespace Codecademy;

$a = 29;
$b = "You did it!";
$c = STR_PAD_BOTH;
$d = "*~*";

// Write your code below:
echo str_pad ($b, $a, $d, $c);

Finding Functions

In order to find out about built-in functions (and other language features), you’ll want to get comfortable exploring the PHP documentation. The docs can get a little overwhelming—for example, this seemingly infinite index of PHP functions is pretty unwieldy.

The documentation contains some lists organized by topic: this is a list of PHP string functions and this is a list of math functions.

It’s often faster to use Google to navigate to the right part of the official documentation (php.net). For example, when I googled “PHP absolute value” the first result was a link to the abs() function in the PHP documentation.

Let’s practice discovering new functions!


Instructions
1.

In the following tasks, you’ll be defining functions which call built-in functions within their function bodies. This time, however, you’ll have to search for the correct built-in function.

Write a function convertToShout() which takes in a string as its argument and returns that string converted to all capital letters and appended with an exclamation point. You should use a specific built-in function to do this conversion.

Once you’ve finished writing your function, you should run it—using echo to see its output—to make sure it’s working how it should.

Here are some examples:

    convertToShout("woah there, buddy") should return "WOAH THERE, BUDDY!"
    convertToShout("i just don't know") should return "I JUST DON'T KNOW!"
    convertToShout("oh, ok, that's fine") should return "OH, OK, THAT'S FINE!"
    convertToShout("it's nice to meet you") should return "IT'S NICE TO MEET YOU!"

2.

Create a function tipGenerously() which takes in a number argument, representing the cost of a meal and returns the number with a 20% tip added rounded up to the nearest integer. You should use a specific built-in function to achieve this rounding.

Once you’ve finished writing your function, you should run it—using echo to see its output—to make sure it’s working how it should.

Here are some examples:

    tipGenerously(100.00) should return 120
    tipGenerously(982.27) should return 1179
    tipGenerously(15.67) should return 19
    tipGenerously(66.18) should return 80
    tipGenerously(21.65) should return 26

3.

Create a function calculateCircleArea() which takes in a circle’s diameter and returns its area. You need to use a built-in function to achieve the exact precision of Pi we’re looking for.

Once you’ve finished writing your function, you should run it—using echo to see its output—to make sure it’s working how it should.

Here are some examples:

    calculateCircleArea(25) should return 490.87385212341
    calculateCircleArea(30) should return 706.8583470577
    calculateCircleArea(872) should return 597204.19707681
    calculateCircleArea(6) should return 28.274333882308
    calculateCircleArea(29) should return 660.51985541725



<?php
namespace Codecademy;

// Write your code below:
function convertToShout($string) {
  $shout = strtoupper($string) . "!";
  return $shout;
}

echo convertToShout("halo thar");

function tipGenerously($cost) {
  $cost += 0.2 * $cost;
  return ceil($cost);
}

echo tipGenerously(45);

function calculateCircleArea($diameter) {
  $pi = pi();
  $square = $pi * (0.5 * $diameter)**2;
  return $square;
}

echo calculateCircleArea(25);

Review

In this lesson, you learned that built-in functions are functions provided by PHP. You learned about several specific built-in functions, how to understand a function’s description in the documentation, and how to discover new built-in functions.

We’ve only started to scratch the surface of all of the functions built into the PHP language. As you continue to learn PHP, you’ll come across many useful built-in functions. As you write your own code, if a task you’re performing feels tedious but common, check to see if there’s a built-in function to do it for you!

One final note: Throughout this lesson, you may have noticed that PHP’s built-in functions often don’t follow the function naming conventions we outlined. PHP’s built-in functions aren’t named following a single convention—some are snake-cased while others have unseparated words. It’s quirks like this that can make PHP a bit frustrating to learn. Be patient with yourself as you get comfortable with the built-in functions most useful to you, and don’t hesitate to look things up.
Instructions

We’ve provided an example of each of the functions we’ve covered in this lesson. Play around with the code to make sure you understand how each one works, or try out some new built-in functions you discover!
Introduction

So far in our PHP programming, we’ve been thinking about individual pieces of data. We’ve seen how useful variables can be for holding a single value, for example. But as our programs grow more complicated, it’s often useful to organize data into collections of elements, and to work with those collections as individual entities.

For example, when we build a to-do list, each item on the list is one piece of data, but the collection of all of the elements together is also a meaningful object. To help us store and manipulate related elements of data together, programming languages employ data structures.

One type of data structure fundamental to computer science is an array, a list of ordered, stored data. In PHP, we refer to this data structure as an ordered array.

The location of an element in an array is known as its index. The elements in an ordered array are arranged in ascending numerical order starting with zero—the index of the first array element is 0, the index of the second is 1, and so on.

Fun fact: Outside of programming, it’s somewhat unusual to see a count that starts at 0 instead of 1, but there’s a reason you’ll see this in many programming languages. In the original implementation of the array data structure, the computer reserved side-by-side spots in memory for each element in an array, but it was too inefficient to keep track of all these memory locations. Therefore, the computer only stored the memory address of the very first element. The index was used to indicate how far away from the start of the array a given element was located. The first element of an array was zero spaces away from that stored address, hence it was at the 0th index.

Creating Arrays with array()

We can construct ordered arrays with a built-in PHP function: array().

The array() function returns an array. Each of the arguments with which the function was invoked becomes an element in the array (in the order they were passed in).

Arrays are most useful when we store them in variables. We create an array variable the same way we create variables of other data types—with the assignment operator.

$my_array = array(0, 1, 2);

In the code above, we constructed an array using the array() function which we captured with the $my_array variable. $my_array is an array with three elements: 0 is located in the 0th index, 1 in the 1st, and 2 in the 2nd.

PHP arrays can store elements of any data type:

$string_array = array("first element", "second element");

In the code above, $string_array holds two string elements. The string "first element" is located at the 0th location index, and the string "second element" is located at the 1st.

PHP arrays can also store elements of multiple data types:

$mixed_array = array(1, "chicken", 78.2, "bubbles are crazy!");

Above, $mixed_array holds four elements—some are strings while others are numbers.

We can use the built-in PHP count() function to get the number of elements in an array. This is especially useful as we work with larger and more complicated arrays:

echo count($my_array); // Prints: 3
echo count($string_array); // Prints: 2
echo count($mixed_array); // Prints: 4

Let’s create some arrays!


Instructions
1.

Create an array variable $first_array. It should have 5 elements. The elements in the 0th, 2nd, and 4th index locations should be strings, and the elements in the 1st and 3rd index locations should be numbers.
2.

Use echo and the built-in count() function to print the length of your array.
<?php
// Write your code below:
$first_array = array("string0", 1, "string2", 3, "string4");
echo count($first_array);
reating Arrays with Short Syntax

In addition to using array(), we can also create an array by wrapping comma-separated elements in square brackets ([ ]). This feature is sometimes referred to as short array syntax, and more closely resembles what you might see in other programming languages.

$number_array = [0, 1, 2];

In the code above, we created the variable $number_array and assigned as its value an array containing the numbers 0, 1, and 2. The number 0 is located at the 0th location index, the number 1 at the 1st, and the number 2 and the 2nd.

Let’s compare using short array syntax with invoking the array() function:

$string_array = array("first element", "second element");
$str_arr_short = ["first element", "second element"];

$mixed_array = array(1, "chicken", 78.2, "bubbles are crazy!");
$mix_arr_short = [1, "chicken", 78.2, "bubbles are crazy!"];

Here, regardless of which method we used, we got the same results.

When constructing arrays, we can also place each element on its own line to make it easier to read:

$long_array = [
  1,
  2,
  3,
  4,
  5,
  6
];

Let’s practice creating some short syntax arrays!


Instructions
1.

We’re going to create two arrays with the same elements.

    The first element should be “PHP”
    The second element should be “popcorn”
    The third element should be 555.55

Name the first array $with_function and create it using the array() function.
2.

Now create the second array. Name it $with_short, and create it using the short array syntax.

Reminder:

    The first element should be “PHP”
    The second element should be “popcorn”
    The third element should be 555.55

<?php
namespace Codecademy;

// Write your code below:
$with_function = array("PHP", "popcorn", 555.55);
$with_short = ["PHP", "popcorn", 555.55];

Printing Arrays

Since arrays are a more complicated data type than strings or integers, printing them is slightly more challenging. Using echo won’t have the desired result:

$number_array = [0, 1, 2];
echo $number_array; // Prints: Array

When we tried to use echo to print $number_array, it printed the word “Array” rather than the contents of the array. To print the contents of the array, we can use PHP built-in functions. The built-in print_r() function outputs arrays in a human readable format:

print_r($number_array);

This will output the array in the following format:

Array
(
    [0] => 0
    [1] => 1
    [2] => 2
)

If we merely want to print the elements in the array listed, we can convert the array into a string using the built-in implode() function. The implode() function takes two arguments: a string to use between each element (the $glue), and the array to be joined together (the $pieces):

echo implode(", ", $number_array);

This will output in the following format:

0, 1, 2 

Let’s practice printing arrays!


Instructions
1.

We’ve created a couple arrays for you. Use the echo and the implode() function to print the $message array using "!" as the $glue.
2.

Use the print_r() function to print the $favorite_nums array.

<?php
namespace Codecademy;

$message = ["Oh hey", " You're doing great", " Keep up the good work!\n"];

$favorite_nums = [7, 201, 33, 88, 91];
// Write your code below:
echo implode("!", $message);
print_r($favorite_nums);

Accessing an Element

The individual elements in an array can be accessed using the array variable’s name, and the location index surrounded by square brackets ([]), for example:

$my_array = ["tic", "tac", "toe"];

echo $my_array[1]; // Prints: tac

This process is sometimes referred to as indexing an array.

Remember the computer evaluates variables it encounters (outside of assignment): it replaces them with the values they hold. Let’s look at an example of indexing an array with a number variable:

$num_var = 2;

$important_info = ["talking chicken", 181, "magnets?!", 99];

echo $important_info[$num_var]; // Prints: magnets?!

Let’s practice accessing elements in arrays!

Accessing an Element

The individual elements in an array can be accessed using the array variable’s name, and the location index surrounded by square brackets ([]), for example:

$my_array = ["tic", "tac", "toe"];

echo $my_array[1]; // Prints: tac

This process is sometimes referred to as indexing an array.

Remember the computer evaluates variables it encounters (outside of assignment): it replaces them with the values they hold. Let’s look at an example of indexing an array with a number variable:

$num_var = 2;

$important_info = ["talking chicken", 181, "magnets?!", 99];

echo $important_info[$num_var]; // Prints: magnets?!

Let’s practice accessing elements in arrays!
Instructions
1.

Create a new array $winners. This array should have three elements—the winning element from each of the three provided arrays. Use array indexing to access the elements.
2.

Use any method you’d like to print the contents of the $winners array

<?php
namespace Codecademy;

$round_one = ["X", "X", "first winner"];

$round_two = ["second winner", "X", "X", "X"];

$round_three = ["X", "X", "X", "X", "third winner"];

// Write your code below:
$winners = [$round_one[2], $round_two[0], $round_three[4]];

print_r($winners);

Adding and Changing Elements

We can make adjustments to existing arrays—we don’t have to create a new array when we want our array to change.

We add elements to the end of an array by taking the variable name and appending square brackets ([]), the assignment operator (=), and the element we want to add:

$string_array = ["first element", "second element"];

$string_array[] = "third element";

echo implode(", ", $string_array); 
// Prints: first element, second element, third element 

We can also reassign the individual elements in an array:

$string_array = ["first element", "second element", "third element"];

$string_array[0] = "NEW! different first element";

echo $string_array[0]; // Prints: NEW! different first element"

In the code above, we replaced the original string held in the array ("first element") with a new string value: "NEW! different first element".
Instructions
1.

We’re going to have you make several changes to the provided $change_me array without making any changes to how it’s initially declared (line 4).

First, add a string element to the end of the array.
2.

Great! Add another element to the end of the array. This time it should be an integer.
3.

Reassign the 1st index location of the array (which currently holds the value 6) to hold the value "tadpole".
4.

Awesome! Let’s take a look at this array of yours. Print your array to the terminal.
<?php
namespace Codecademy;

$change_me = [3, 6, 9];
// Write your code below:
$change_me[3] = "string";
$change_me[] = 2;
$change_me[1] = "tadpole";
print_r ($change_me);

More Array Methods: Pushing and Popping

In the previous exercise, we learned how to add single array elements and to change array elements at a given index. PHP also provides us with built-in methods for removing array elements, and for adding many elements at once.

The array_pop() function takes an array as its argument. It removes the last element of an array and returns the removed element.

$my_array = ["tic", "tac", "toe"];
array_pop($my_array); 
// $my_array is now ["tic", "tac"]
$popped = array_pop($my_array); 
// $popped is "tac"
// $my_array is now ["tic"]

Note that array_pop() doesn’t just set the last element to NULL. It actually removes it from the array, meaning that array’s length will decrease by one (which we can verify using count()).

The array_push() function takes an array as its first argument. The arguments that follow are elements to be added to the end of the array. array_push() adds each of the elements to the array and returns the new number of elements in the array.

$new_array = ["eeny"];
$num_added = array_push($new_array, "meeny", "miny", "moe"); 
echo $num_added; // Prints: 4
echo implode(", ", $new_array); // Prints: eeny, meeny, miny, moe 

Let’s practice!


More Array Methods: Pushing and Popping

In the previous exercise, we learned how to add single array elements and to change array elements at a given index. PHP also provides us with built-in methods for removing array elements, and for adding many elements at once.

The array_pop() function takes an array as its argument. It removes the last element of an array and returns the removed element.

$my_array = ["tic", "tac", "toe"];
array_pop($my_array); 
// $my_array is now ["tic", "tac"]
$popped = array_pop($my_array); 
// $popped is "tac"
// $my_array is now ["tic"]

Note that array_pop() doesn’t just set the last element to NULL. It actually removes it from the array, meaning that array’s length will decrease by one (which we can verify using count()).

The array_push() function takes an array as its first argument. The arguments that follow are elements to be added to the end of the array. array_push() adds each of the elements to the array and returns the new number of elements in the array.

$new_array = ["eeny"];
$num_added = array_push($new_array, "meeny", "miny", "moe"); 
echo $num_added; // Prints: 4
echo implode(", ", $new_array); // Prints: eeny, meeny, miny, moe 

Let’s practice!
Instructions
1.

We provided you an array $stack. Use the array_push() function to add two elements to the array: "blocker" and "impediment".
2.

Use the array_pop() function to remove all but one element from the array.

<?php
namespace Codecademy;

$stack = ["wild success", "failure", "struggle"];
// Write your code below:
array_push($stack, "blocker","impediment");

print_r($stack);

array_pop($stack);
array_pop($stack);
array_pop($stack);
array_pop($stack);

print_r($stack);

Shifting and Unshifting

We saw that array_pop() and array_push() deal exclusively with the end of the array (the index at the length of the array minus 1). PHP also provides functions for adding and removing elements from the beginning of an array (index 0).

The array_shift() function removes the first element of an array and returns that value. Each of the elements in the array will be shifted down an index. For example, the element that was previously at the 3rd index will now be located at the 2nd.

$adjectives = ["bad", "good", "great", "fantastic"];
$removed = array_shift($adjectives); 
echo $removed; //Prints: bad
echo implode(", ", $adjectives); // Prints: good, great, fantastic 

Just like array_pop(), array_shift() reduces the length of the array, and the deleted element is gone for good.

The array_unshift() function takes an array as its first argument. The arguments that follow are elements to be added to the beginning of the array. It returns the new number of elements in the array.

$foods = ["pizza", "crackers", "apples", "carrots"];
$arr_len = array_unshift($foods, "pasta", "meatballs", "lettuce"); 
echo $arr_len; //Prints: 7
echo implode(", ", $foods); 
// Prints: pasta, meatballs, lettuce, pizza, crackers, apples, carrots

Let’s practice!


Instructions
1.

Let’s use arrays (and our imaginations) to go on a journey through the history of the 100-meter dash.

In 1991 Carl Lewis broke the record of 9.90 seconds. His record was topped in 1994 by Leroy Burrell. Next in 1996, Donovan Bailey took the record only to have his record usurped by Maurice Greene in 1999, then Tim Montgomery in 2002.

We’ve provided an array $record_holders. Use the array_unshift() function to add "Carl Lewis", "Leroy Burrell", "Donovan Bailey", "Maurice Greene", and "Tim Montgomery" to the $record_holders.

Add the names so that older records always have higher index locations than more recent records.

Note: It’s not required, but you might find it helpful to periodically print your array.
2.

Oops. Tim Montgomery’s record was invalidated. Use the array_shift() function to remove him from the $record_holders array.
3.

Great! Next up we have "Asafa Powell" in 2005 followed by "Justin Gatlin" in 2006. Use the array_unshift() function to add them to the $record_holders array.
4.

Justin Gatlin’s record was also invalidated. Use the array_shift() function to remove him from the $record_holders array.
5.

Ok, last but not least, use array_unshift() function to add "Usain Bolt" to the $record_holders array.


<?php
namespace Codecademy;
$record_holders = [];
// Write your code below:
array_unshift($record_holders, "Tim Montgomery", "Maurice Greene", "Donovan Bailey", "Leroy Burrell", "Carl Lewis");
print_r($record_holders);

array_shift($record_holders);
print_r($record_holders);

array_unshift($record_holders, "Justin Gatlin", "Asafa Powell");
print_r($record_holders);

array_shift($record_holders);
print_r($record_holders);

array_unshift($record_holders, "Usain Bolt");
print_r($record_holders);

Nested Arrays

We mentioned that arrays can hold elements of any type—this even includes other arrays! We can use chained operations to access and change elements within a nested array:

$nested_arr = [[2, 4], [3, 9], [4, 16]];
$first_el = $nested_arr[0][0];
echo $first_el; // Prints: 2

Above, $nested_arr is an array with three array elements. The first, located at the 0th index, is the array [2, 4]. The expression $nested_arr[0] returns that array. We then index that array’s first element by appending an additional [0].

This can take practice to get used to. One helpful technique is to act like the computer; evaluate each part of the expression from left to right. By breaking down a complex expression into its simpler parts, it becomes easier to understand. Let’s walk through a more complicated example together:

$very_nested = [1, "b", 33, ["cat", 6.1, [9, "LOST!", 6], "mouse"], 7.1];

We want to change the element which is currently "LOST!" to "Found!". Let’s breakdown the steps:

    We need the outermost array first: $very_nested[3] evaluates to the array ["cat", 6.1, [9, "LOST!", 6], "mouse"]
    Next we need the array located at the 2nd location index: $very_nested[3][2] evaluates to the array [9, "LOST!", 6]
    And finally, the element we’re looking for: $very_nested[3][2][1] evaluates to "LOST!"

    $very_nested[3][2][1] = "Found!";

Let’s get some more practice with nested arrays!


Instructions
1.

We’re going treasure hunting! Hidden within this terribly nested array is the string "GOLD!". Your job is use echo to print it to the terminal. The trick: you must use array indexing to accomplish this goal. It’s up to you whether you do this in one step or break it down into multiple steps.
<?php
namespace Codecademy;


$treasure_hunt = ["garbage", "cat", 99, ["soda can", 8, ":)", "sludge", ["stuff", "lint", ["GOLD!"], "cave", "bat", "scorpion"], "rock"], "glitter", "moonlight", 2.11];
  
// Write your code below:
echo $treasure_hunt[3][4][2][0];

Review

We covered a lot in this lesson! Great job. Take a second to review everything you learned:

    Arrays are ordered collections of data that are a type of data structure fundamental to computer science.
    In PHP, we refer to this data structure as ordered arrays.
    The location of an element in an array is known as its index.
    The elements in an ordered array are arranged in ascending numerical order starting with index zero.
    We can construct ordered arrays with a built-in PHP function: array().
    We can construct ordered arrays with short array syntax, e.g. [1,2,3].
    We can print arrays using the built-in print_r() function or by converting them into strings using the implode() function.
    We use square brackets ([]) to access elements in an array by their index.
    We can add elements to the end of an array by appending square brackets ([]) to an array variable name and assigning the value with the assignment operator (=).
    We can change elements in an array using array indexing and the assignment operator.
    The array_pop() function removes the last element of an array.
    The array_push() function adds elements to the end of an array.
    The array_shift() function removes the first element of an array.
    The array_unshift() function adds elements to the beginning of the array.
    We can use chained square brackets ([]) to access and change elements within a nested array.

Introduction

Ordered arrays are awesome when we have data that lends itself to being collected into an ordered (indexed) list. But data can be collected and organized in lots of ways.

Imagine we wanted a data structure to hold a bunch of information about ourself: our name, age, email address, birthday, social security number, and favorite food. We want all of these pieces of data in a single collection but not necessarily in any particular order. And it doesn’t make much sense to access these data items using indices, like in an ordered array. It would be hard to remember, for example, that index 0 corresponds to our name.

Time to meet another fundamental concept in computer science—the map. A map associates keys with values. A key is a string or integer that we use to access a value (of any type). We could create a map with a key "fullname" that points to a value of "Aisle Nevertell"; this is much more understandable than associating the name with index 0. Whenever we need to access a value, we’ll be able to use the associated key to find it.

Associative Arrays

Associative arrays are collections of key=>value pairs. The key in an associative array must be either a string or an integer. The values held can be any type. We use the => operator to associate a key with its value. key/value pairs We can think of keys as pointing to their values since the key points the computer to the space in memory where the value is stored.

$my_array = ["panda" => "very cute", "lizard" => "cute", "cockroach" => "not very cute"];

In the code above, we created an associative array using short array syntax. $my_array has three key=>value pairs:

    The key "panda" points to the value "very cute".
    The key "lizard" points to the value "cute".
    The key "cockroach" points to the value "not very cute".

We can also build associative arrays using the PHP array() function.

$about_me = array(
    "fullname" => "Aisle Nevertell",
    "social" => 123456789
);

In the code above, we created an associative array, $about_me, with two key=>value pairs:

    The key "fullname" points to the value "Aisle Nevertell".
    The key "social" points to the value 123456789.

Let’s make some arrays!


Instructions
1.

Use the array() function to create an array $php_array which has the following key => value pairs:

    The key "language" should point to the value "PHP".
    The key "creator" should point to the value "Rasmus Lerdorf".
    The key "year_created" should point to the value 1995.
    The key "filename_extensions" should point to the value [".php", ".phtml", ".php3", ".php4", ".php5", ".php7", ".phps", ".php-s", ".pht", ".phar"] (an ordered array).

2.

Use the short array syntax to create an array $php_short which has the same key => value pairs.

<?php
namespace Codecademy;

// Write your code below:
$php_array = array("language"=>"PHP", "creator"=>"Rasmus Lerdorf", "year_created"=>1995, "filename_extensions"=>[".php", ".phtml", ".php3", ".php4", ".php5", ".php7", ".phps", ".php-s", ".pht", ".phar"]);
$php_short = ["language"=>"PHP", "creator"=>"Rasmus Lerdorf", "year_created"=>1995, "filename_extensions"=>[".php", ".phtml", ".php3", ".php4", ".php5", ".php7", ".phps", ".php-s", ".pht", ".phar"]];

Printing Associative Arrays

As with ordered arrays, using echo to print an entire associative array is not very useful:

$grades = [
    "Jane" => 98,
    "Lily" => 74,
    "Dan" => 88,
];

echo $grades; // Prints: Array

We can combine each of the values contained by the array into a single string and use echo to print that:

echo implode(", ", $grades); // Prints: 98, 74, 88 

A problem with this technique is that it only displays the values. We don’t see the keys in the array or the relationships between the keys and values. To display this information, we can use the built-in print_r() function:

print_r($grades);

The above code will produce the following output:

Array
(
    [Jane] => 98
    [Lily] => 74
    [Dan] => 88
)

Let’s print some associative arrays!

Instructions
1.

You’re going to construct an array of the top grossing movies of September 1999 and how much money they made. Name your array $september_hits. The array should have the following key => value pairs:

    The key "The Sixth Sense" should point to the the value 22896967.
    The key "Stigmata" should point to the the value 18309666.
    The key "Blue Streak" should point to the value 19208806.
    The key "Double Jeopardy" should point to the value 23162542.

You can use any method you’d like to construct this array.
2.

Use the echo and the implode() function to print the values in $september_hits. You can use any characters you’d like to join the array elements.
3.

Use the print_r() function to print $september_hits.


<?php
namespace Codecademy;

// Write your code below:
$september_hits = ["The Sixth Sense" => 22896967, "Stigmata" => 18309666, "Blue Streak" => 19208806, "Double Jeopardy" => 23162542];

echo implode(", ", $september_hits);
print_r($september_hits);

Accessing and Adding Elements

We access the value a given key points to using square brackets ([]):

$my_array = ["panda"=>"very cute", "lizard"=>"cute", "cockroach"=>"not very cute"];
echo $my_array["panda"]; // Prints: very cute

In the code above, we accessed the value "very cute" using its key, "panda".

To add new elements to an associative array, we use the assignment operator (=):

$my_array["capybara"] = "cutest";
echo $my_array["capybara"]; // Prints: cutest

In the code above, we added a fourth key value pair to the array. We accessed the new value "cutest" using its key "capybara" and printed it using echo.

The computer treats code between the square brackets as an expression, so that code will be evaluated before the array is accessed. This enables us to use variables, functions, and operators within the square brackets:

$favorites = ["favorite_food"=>"pizza", "favorite_place"=>"my dreams", "FAVORITE_CASE"=>"CAPS","favorite_person"=>"myself"];

echo  $favorites["favorite" . "_" . "food"]; 
// Prints: pizza

$key =  "favorite_place";
echo  $favorites[$key];  
// Prints: my dreams

echo $favorites[strtoupper("favorite_case")];
// Prints: CAPS

Let’s access some elements!


Instructions
1.

We provided you with three arrays $assignment_one, $assignment_two, $assignment_three. These arrays each hold students’ grades for a given assignment. Two key=>value pairs need to be added:

    Sara turned in her second assignment late—she got a 65.
    Kat’s third assignment was briefly misplaced—she got a 97.

You should complete this task without changing the code we’ve provided.
2.

Create a new ordered array named $dans_grades which holds Dan’s grades from each of the three assignments. To add these elements to the new array, access them from each of the provided arrays using the key "Dan".
3.

We provided you with the variable $student_name. Use echo to print the result of accessing $assignment_two with the $student_name variable.


<?php
namespace Codecademy;
$assignment_one = ["Alex"=> 87, "Kenny"=> 91, "Natalia"=> 91, "Lily"=> 67, "Dan"=> 81, "Kat"=> 77, "Sara" => 65];

$assignment_two = ["Alex"=> 91, "Kenny"=> 99, "Natalia"=> 100, "Lily"=> 61, "Dan"=> 88, "Kat"=> 90];

$assignment_three = ["Alex"=> 78, "Kenny"=> 92, "Natalia"=> 94, "Lily"=> 79, "Dan"=> 73, "Sara" => 61];

$student_name = "Alex";
// Write your code below:
$assignment_two["Sara"] = 65;
$assignment_three["Kat"] = 97;

$dans_grades = [$assignment_one["Dan"], $assignment_two["Dan"], $assignment_three["Dan"]];

echo $assignment_two[$student_name];

The PHP array type that we’ve been working with is actually implemented as a map! In a PHP ordered array, the index locations are the keys. But the PHP array type also enables us to build more traditional map-like structures where we assign meaningful keys to values (as opposed to indices). We call data structures like this associative arrays.

Changing and Removing Elements

The same syntax that adds new array elements can be used to change existing elements:

$new_arr = ["first" => "I am first!", "second" => "I am second!"]; 

$new_arr["third"] = "I am third!";

echo $new_arr["third"]; // Prints: I am third!

$new_arr["third"] = "I am the *NEW* third!";

echo $new_arr["third"]; // Prints: I am the *NEW* third!

In the above code, we use the same syntax to add a key=>value pair ("third" => "I am third!") as we do to assign that key a new value ("third" => "I am the *NEW* third!").

Since PHP will allow us to add a new key=>value pair or change an existing value using exactly the same code, we’ll need to use caution to avoid accidentally overwriting an existing value.

We can remove a key=>value pair entirely using the PHP unset() function. Note: if the key used doesn’t exist in the array, then nothing happens.

$nums = ["one" => 1,"two"=> 2];

echo implode(", ", $nums); // Prints: 1, 2

unset($nums["one"]);

echo implode(", ", $nums); // Prints: 2

In the code above, we created an associative array with two key => value pairs. We then removed the pair "one" => 1 using the unset() function.

Let’s practice changing and removing elements!


Instructions
1.

We’ve provided an associative array, $my_car, with key=>value pairs that relate to elements (or parts) of our car. Some things, like our brakes, seem to be in great shape, but others could use some work…

Change the value associated with the key "oil" from its current value ("black and clumpy") to the value "new and premium".

Note: Accomplish this task without changing the code we wrote.
2.

Change the value associated with the key "tires" from its current value ("old with worn treads") to the value "new with deep treads".

Note: Accomplish this task without changing the code we wrote.
3.

We’d love a clean car. Use the unset() function to remove the "filth" from our car please.
4.

At the bottom of your code, use print_r() to print out $my_car so you can see all the changes to made to the array.


<?php
namespace Codecademy;

$my_car = [
  "oil" => "black and clumpy",
  "brakes" => "new",
  "tires" => "old with worn treads",
  "filth" => "bird droppings", 
  "wiper fluid" => "full", 
  "headlights" => "bright"
];
print_r($my_car);

// Write your code below:
$my_car["oil"] = "new and premium";
$my_car["tires"] = "new with deep treads";
unset($my_car["filth"]);

print_r ($my_car);

Numerical Keys

Associative arrays can use integers as keys, in addition to strings.

$num_array = [1000 => "one thousand", 100 => "one hundred", 600 => "six hundred"];
echo $num_array[1000]; // Prints: one thousand

When we build ordered arrays in PHP, the association with numerical keys to values is done for us automatically. The first element is associated with the key 0, the second with 1, and so on. But ordered arrays are still the same structure as associative arrays. We can mix and match:

$ordered = [99, 1, 7, 8];
$ordered["special"] = "Cool!";
echo $ordered[3]; // Prints: 8
echo $ordered["special"]; // Prints: Cool!

When we add an element to an array without specifying a key (e.g. using array_push()), PHP will associate it with the “next” integer key. If no integer keys have been used, it will associate it with the key 0, otherwise it will associate it one more than the largest integer used thus far. This behavior is the same whether the array is being used as an ordered array or an associative array. Let’s look at an example:

$num_array = [1000 => "one thousand", 100 => "one hundred", 600 => "six hundred"];
$num_array[] = "New Element in \$num_array";
echo $num_array[1001]; // Prints: New Element in $num_array

$animals_array = ["panda"=>"very cute", "lizard"=>"cute", "cockroach"=>"not very cute"];
array_push($animals_array, "New Element in \$animals_array");
echo $animals_array[0]; // Prints: New Element in $animals_array

Even though associative arrays and ordered arrays are technically the same, we recommend treating them as separate data types. Only use the empty square brackets syntax (or functions like array_push()) with ordered arrays.

But, for now, let’s break this rule a little to get used to the ins and outs of PHP arrays!

Instructions
1.

Create an ordered array named $hybrid_array. It should have four elements which can be any values you’d like.
2.

You’re going to add a key=>value pair to $hybrid_array. The value you add should be "five more" and it should be associated to an integer key equal to five more than the largest integer key already in use in $hybrid_array.

Use the print_r() function to print $hybrid_array and confirm all the key=>value pairs are what you expect.
3.

This time, you’re going to add a random number to the array using the array_push() function. Don’t use any additional variables to accomplish this task. Instead, you should push rand() directly.

What do you think the key associated with the random value is?
4.

Use echo and array indexing to print out the random number value you added to $hybrid_array.


<?php
namespace Codecademy;

// Write your code below:
$hybrid_array = ["zero", "one", "two", "three"];
$hybrid_array[8] = "five more";
print_r($hybrid_array);

array_push($hybrid_array, rand());
echo ($hybrid_array[9]);

Joining Arrays

PHP also lets us combine arrays. The union (+) operator takes two array operands and returns a new array with any unique keys from the second array appended to the first array.

$my_array = ["panda" => "very cute", "lizard" => "cute", "cockroach" => "not very cute"];
$more_rankings = ["capybara" => "cutest", "lizard" => "not cute", "dog" => "max cuteness"];
$animal_rankings = $my_array + $more_rankings;

The $animal_rankings we created above will have each of the key=>value pairs from $my_array. In addition, it will contain the key=>value pairs from $more_rankings: "capybara"=>"cutest" and "dog"=>"max cuteness". However, since "lizard" is not a unique key, $animal_rankings["lizard"] will retain the value of $my_array["lizard"] (which is "cute").

The union operator can be a little tricky… consider the following union:

$number_array = [8, 3, 7];

$string_array = ["first element", "second element", "third element"];

$union_array = $number_array + $string_array;

What values does $union_array hold? It has the elements 8, 3, and 7. Since the two arrays being joined have identical keys (0, 1, and 2), no values from the second array, $string_array, are included in $union_array.

Let’s get some practice!

Instructions
1.

All the animals are throwing a potluck party! Generous Giraffe is bringing an assortment of foods—recorded in the $giraffe_foods array. Industrious Impala is bringing a bunch of food as well ($impala_foods).

Using the union operator (+), create an array, $potluck representing all the food that will be brought by these two animals!
2.

Use print_r() to print the $potluck array to the terminal.
3.

Uh oh. Who invited Redundant Rat? Redundant Rat is bringing a lot of food types that have already been accounted for… Only one item from $rat_foods would be added to the $potluck array if it were joined to it. Can you tell which one?

It’s not required, but you might try joining the arrays in different orders and printing the results to see what’s going on! Otherwise, just click “Run” to continue.


<?php
namespace Codecademy;

$giraffe_foods = ["dip"=>"guacamole", "chips"=>"corn", "entree"=>"grilled chicken"];

$impala_foods = ["dessert"=>"cookies", "vegetable"=>"asparagus", "side"=>"mashed potatoes"];

$rat_foods = ["dip"=>"mashed earth worms", "entree"=>"trash pizza", "dessert"=>"sugar cubes", "drink"=>"lemon water"];

// Write your code below:
$potluck = $giraffe_foods + $impala_foods;
print_r($potluck);

Assign by Value or by Reference

There are two ways to assign one variable to another:

    By value—this creates two variables which hold copies of the same value but remain independent entities.
    By reference—this creates two variable names (aliases) which point to the same space in memory. They cannot be modified separately!

This remains true when dealing with array variables:

$favorites = ["food"=>"pizza", "person"=>"myself", "dog"=>"Tadpole"];
$copy = $favorites;
$alias =& $favorites;
$favorites["food"] = "NEW!";

echo $favorites["food"]; // Prints: NEW!
echo $copy["food"]; // Prints: pizza
echo $alias["food"]; // Prints: NEW!

When passing arrays into functions, both built-in functions and those we write ourselves, we’ll want to be conscious of whether the arrays are being passed by value or by reference.

function changeColor ($arr) 
{
  $arr["color"] = "red";    
}
$object = ["shape"=>"square", "size"=>"small", "color"=>"green"];
changeColor ($object);
echo $object["color"]; // Prints: green

Our function above doesn’t accept its array argument by reference. Therefore, $arr is merely assigned a copy of the argument’s value. This copy array is changed when the function is invoked, but that doesn’t affect the orginal argument array ($object). To do that, we’d need to pass it by reference:

function reallyChangeColor (&$arr) 
{
  $arr["color"] = "red";    
}
$object = ["shape"=>"square", "size"=>"small", "color"=>"green"];
reallyChangeColor ($object);
echo $object["color"]; // Prints: red

Cool! Let’s write some array functions!


Instructions
1.

Create a function, createMeme() that takes in a $meme array and returns a new custom meme about PHP.

The $meme array will have the following keys: "top_text", "bottom_text", "img", and "description".

The function should change the value of "top_text" to "Much PHP" and the "bottom_text" to "Very programming. Wow."

The function should not permanently alter its argument.
2.

Create a variable $php_doge and assign as its value the result of invoking your createMeme() with $doge_meme.

Note: we recommend using the print_r() function to see the arrays you’re creating and using, but it’s not required.
3.

Write a function fixMeme() that takes in a $meme array and permanently changes the "top_text" and "bottom_text" to strings of your chosing.
4.

Invoke your fixMeme() function with the $bad_meme array we provided.


<?php
namespace Codecademy;
$doge_meme = ["top_text" => "Such Python", "bottom_text" => "Very language. Wow.", "img" => "very-cute-dog.jpg", "description" => "An adorable doge looks confused."];

$bad_meme = ["top_text" => "i don't know", "bottom_text" => "i can't think of anything", "img" => "very-fat-cat.jpg", "description" => "A very fat cat looks happy."];

// Write your code below:
function createMeme ($meme) 
{
  $meme["top_text"] = "Much PHP";
  $meme["bottom_text"] = "Very programming. Wow.";
  return $meme;
}  

print_r($doge_meme);

$php_doge = createMeme($doge_meme);

print_r($php_doge);

function fixMeme (&$meme) 
{
  $meme["top_text"] = "I can haz";
  $meme["bottom_text"] = "PHP, plz?";
  return $meme;
} 

print_r($bad_meme);

fixMeme ($bad_meme);

print_r($bad_meme);

Review

You learned so much in this lesson! Let’s review:

    Associative arrays are data structures in which string or integer keys are associated with values.
    We use the => operator to associate a key with its value. $my_array = ["panda"=>"very cute"]
    To print an array’s keys and their values, we can use the print_r() function.
    We access the value associated with a given key by using square brackets ([ ]). For example: $my_array["panda"] will return "very cute".
    We can assign values to keys using this same indexing syntax and the assignment operator (=): $my_array["dog"] = "good cuteness";
    This same syntax can be used to change existing elements. $my_array["dog"] = "max cuteness";
    We can remove a key=>value pair entirely using the PHP unset() function.
    Keys can be integers. In fact, ordered arrays are just arrays in which integer keys have been assigned to the values automatically.
    In PHP, associative arrays and ordered arrays are different uses of the same data type.
    The union (+) operator takes two array operands and returns a new array with any unique keys from the second array appended to the first array.
    When writing function with array parameters, we can pass the array by value or by reference depending on our intent.

Introduction

PHP can be used in many ways. It can be used to write standalone programs that run in our terminal:

echo "Hello, World!";

When run, the code above will output the following to the terminal:

Hello, World!

But PHP was designed as a back-end web development language—specifically it was designed to work well with HTML. PHP allowed a convenient way for developers to create HTML templates and programatically fill them out in order to send customized HTML to visitors of their sites.

PHP has evolved into a powerful programming language being used for more than templating HTML, but using PHP combined with HTML remains an important part of many web developers’ skill sets.

In this lesson, we’ll delve into the difference between the front-end and the back-end and learn how to use PHP to generate HTML. If you’d like a refresher on HTML check out these lessons. Otherwise let’s dive in!

What is the Front-End?

Let’s talk about the difference between a front-end language and a back-end language. HTML is a front-end language, but what exactly does that mean?

When navigating to a website from our web browser, the browser makes a request for content on our behalf. What we see and experience as a single website is actually composed of a number of files which come together to form a cohesive experience.

The files we receive consist of JavaScript, CSS, HTML, images, and other static assets. A static asset is a file that doesn’t change. When we navigate to a webpage, these assets are sent to a browser.

You may have heard front-end development referred to as client-side development. In web development, we are typically referring to the browser as the client. A human may be experiencing the website, but it’s the browser that makes requests for information and receives the responses.

The front-end of a website or web application consists of all the elements of the website that are sent to the client upon request. But something has to be listening for those requests and deciding what to send — it’s the back-end of the website that does all that and more.

What is the Back-End?

The back-ends of websites will differ depending on the needs of the site. Typically, they’ll have at least the following components:

    A web server: a web server is a computer or program which listens for requests from clients and sends back responses. This component is well suited to handling delivery of static content.
    An application server: this is actually often a collection of programming logic which is needed to deliver dynamic content to a client. The application server will often handle other tasks such as site security and interacting with data.
    A data base: important information like usernames and passwords has to be stored and accessed somewhere. A large web application will often have multiple databases to store all different types of data needed to run the site smoothly.

PHP can be used in many capacities in the back-end. However, in this lesson, we’ll get started small by focussing on one small role the PHP application server can play in generating HTML which the web server will send to a client.


PHP in HTML

We can embed PHP scripts within HTML documents with the opening tag <?php and the closing tag ?>. The PHP processor will read the entire file, evaluate any PHP, translate it into HTML, and pass it off to the web server so it can be sent to the client.

Consider the following code:

<html>
 <head>
  <title>My First PHP Site</title>
 </head>
 <body>
 <?php 
    echo "<h1>Oh hi!</h1>"; 
  ?> 
 </body>
</html>

In the code above, the line echo "<h1>Oh hi!</h1>" will generate an HTML header of Oh hi!.

When we use echo within HTML we’re no longer printing to the terminal, rather we’re outputting to the HTML document.

Wouldn’t it have been simpler to just add <h1>Oh hi!</h1> directly? Yep. This example certainly doesn’t show us why we’d want to use PHP within our HTML. As we learn to develop more robust PHP scripts and harness some of the language’s more complex features, we’ll grow to understand how powerful it can be.

For now, let’s get a better understanding of how we can use PHP within HTML.


Instructions
1.

You’ll notice that the workspace now has a file titled index.php instead of index.html. We’re using the php extension because we want to add some PHP code to it.

Currently, this page is the same as a static HTML document. Add a new paragraph using PHP and echo.

The paragraph should say This is PHP.

<html>
<body>
<h1>PHP and HTML</h1>
<p>This is HTML</p>
<?php echo "<p>This is PHP</p>"?>
</body>
</html>

Beyond Strings

We can also incorporate more complex PHP within our scripts.

<?php
$lucky_number = 5 * 2 - 1;

echo "<h1>Your lucky number is ${lucky_number}</h1>";
?>

The code above will be translated into HTML with a header that reads: Your lucky number is 9.

We can incorporate all the language features we know about PHP, including functions:

<?php
function makeHeaderGreeting ($name){
  return "<h1>Hello, ${name}!</h1>";
}

echo makeHeaderGreeting("World");
?>

The code above will be translated into HTML with a header that reads: Hello, World!.

Instructions
1.

At the top of index.php, we’ve added some PHP variables and functions.

In these checkpoints, you’ll be adding code within the PHP block under the h2 tag.

This section will contain information about the data stored in $about_me.

First things first - let’s introduce the person. Access the 'name' from the $about_me array within your introduction. Place this greeting in an h3 tag.
2.

You can pass a person’s data array (like $about_me) into the calculateAge function to determine someone’s age.

Add a paragraph tag under the h3 and state how old this person is. Be sure to use calculateAge. You may have to use PHP’s concatenation operator.
3.

Add a final div and use it to tell us the person’s favorite food.

<?php 
$about_me = [
  "name" => "Aisle Nevertell",
  "birth_year" => 1902,
  "favorite_food" => "pizza"
];

function calculateAge ($person_arr){
  $current_year = date("Y");
  $age = $current_year - $person_arr["birth_year"];
  return $age;
}
?>
<h1>Welcome!</h1>
<h2>About me:</h2>
<?php   
  echo "<h3>Hello! I'm {$about_me["name"]}!</h3>";
  echo "<p> I'm " . calculateAge($about_me). " years old! That's pretty cool, right?</p>";
  echo "<div>What more is there to say? I love {$about_me["favorite_food"]}, and that's pretty much it!</div>";
?>

<h2>Now tell me a little about you.</h2>
Review

In this lesson, you’ve begun to learn how to use PHP to generate HTML. This will become even more powerful as we learn how to get information from the client and use that to create dynamic websites.

Let’s review what we’ve learned so far:

    The front-end of a website consists of JavaScript, CSS, HTML, images, and other static assets sent to the client.
    When we navigate to a website the browser is the client, and it sends a request to the back-end for all the assets needed to view and interact with the website.
    The back-end consists of a web server and all the logic and data needed to create and maintain a website or web application.
    PHP is a back-end language.
    PHP can be used to generate HTML files.
    We embed PHP scripts within HTML by inserting PHP code between the opening (<?php) and closing (?>) tags.

Introduction

Presenting and interacting with HTML is one of the primary uses of PHP. Our server takes each PHP file (in our examples, this is index.php), and translates them into HTML to present to the client in their web browser.

This process allows for developers to create customized experiences for individual users.

PHP also provides the capability to handle input from users through HTML forms in a straightforward manner. Before we cover working with forms, take a minute to review how PHP code can be embedded into HTML:

<p>This HTML will get delivered as is</p>
<?php echo "<p>PHP interprets this and turns it into HTML</p>";?>
<p>This HTML will get delivered as is</p>

This example uses the PHP opening (<?php) and closing (?>) tags to insert PHP code. It uses echo to add text to the HTML. This practice is so common that PHP provides a shorthand syntax. Instead of using <?php echo to begin the statement, you can simply use <?=.

Our example becomes:

<p>This HTML will get delivered as is</p>
<?="<p>PHP interprets this and turns it into HTML</p>";?>
<p>This HTML will get delivered as is</p>



Instructions
1.

We’ve included an example in index.php that uses the full PHP opening tag and echo to insert a statement into the HTML.

Convert this to use the shorthand syntax.

<h1>Learning PHP and HTML</h1>
<p>This first paragraph is standard HTML</p>
<?= "<p>Let's insert some text into our HTML using PHP!</p>";?>
<p>This last paragraph is also standard HTML</p>

Request Superglobals

Since PHP was built with web development as a primary use case, it has functionality to ease processing of HTML requests. When the front end client makes a request to a backend PHP server, several superglobals related to the request are available to the PHP script. Superglobals are automatic global variables which are available in all scopes throughout a script.

The list of superglobals in PHP includes the following:

    $GLOBALS
    $_SERVER
    $_GET
    $_POST
    $_FILES
    $_COOKIE
    $_SESSION
    $_REQUEST
    $_ENV

For this lesson, we are focusing on three of these:

    $_GET - this contains an associative array of variables passed to the current script using query parameters in the URL
    $_POST - this contains an associative array of variables passed to the current script using a form submitted using the “POST” method
    $_REQUEST - this contains the contents of $_GET, $_POST, and $_COOKIE

Instructions
1.

In the code, we’ve set up two HTML forms, one using the “GET” method and one using the “POST” method.

Print the values of the $_REQUEST, $_GET, and $_POST superglobals after their corresponding text in the HTML using the built-in print_r function.
2.

Try typing some words into each of the forms and submitting them to examine the behavior of these superglobals. Use the “reset” button to reset the form.

When does the URL in the demo browser change?
<html>
<body>
$_REQUEST:
<?php print_r($_REQUEST) ?>
<br>
$_GET:
<?php print_r($_GET) ?>
<br>
$_POST:
<?php print_r($_POST) ?>
<form method="get">
GET Form: <input type="text" name="get_name">
<input type="submit" value="Submit GET">
</form>
<form method="post">
POST Form: <input type="text" name="post_name">
<input type="submit" value="Submit POST">
</form>
<a href="index.php">Reset</a>
</body>
</html>

Instructions
1.

We’ve added a form to collect a user’s country and language. Add a method attribute to the form to specify that you want to use the GET method.

(The default method is actually “get”, but it’s best practice to set this explicitly)
2.

If you try submitting the form, you may notice that the URL is not changing to include URL parameters as you might expect. This is because neither input has a name attribute yet.

Give the first input a name of country and the second input a name of language.
3.

Use the PHP shorthand to print the user’s country and language from the $_GET superglobal array.

You should be replacing the HTML comments that say:

<!--Add step 3 code here-->

<html>
<body>
<form method="get">
Country:
<input type="text" name="country">
<br>
Language:
<input type="text" name="language">
<br>
<input type="submit" value="Submit">
</form>
<br>
<p>Your language is: <?=$_GET['language'];?></p>
<p>Your country is: <?=$_GET['country'];?></p>
<a href="index.php">Reset</a>
</body>
</html>

POST Form Handling

In HTML, setting a form’s method attribute to "post" specifies that you would like the form to be submitted using the POST method. When using POST to submit forms, you will not see the URL change. The form data is sent using the headers of the HTTP request instead of URL parameters.

To use the data from the form in PHP, each input needs to have a unique name attribute.

When the form is submitted, the input data is available in the $_POST superglobal. Similar to GET, it is also available in $_REQUEST.

For example, if a user typed “Katharine” into the first input and “McCormick” into the last input of this form:

<form method="post">
First name: <input type="text" name="first">
<br>
Last name: <input type="text" name="last">
<br>
<input type="submit" value="Submit Name">
</form>

The URL would not change and print_r($_POST) would look like this:

Array ( [first] => Katharine [last] => McCormick )

Instructions
1.

We’ve added a form to collect a user’s favorite food and color. Add a method attribute to the form to specify that you want to use the POST method.
2.

To use the inputs in PHP, they need to have names.

Give the first input a name of color and the second input a name of food.
3.

Use the PHP shorthand to print the user’s favorite food and color from the $_POST superglobal array.

You should be replacing the HTML comments that say:

<!--Add step 3 code here-->

<html>
<body>
<form method="post">
Favorite Color:
<input type="text" name="color">
<br>
Favorite Food:
<input type="text" name="food">
<br>
<input type="submit" value="Submit">
</form>
<br>
<p>Best food is: <?= $_POST['food'];?></p>
<p>Best color is: <?= $_POST['color'];?></p>
<a href="index.php">Reset</a>
</body>
</html>

Using the "action" Attribute

Until now, we’ve been handling the response to the form submission on the same page as the form itself. Often times there is no need to present a user with the same form over and over again. It might make sense to move them to a new page or thank them for their submission.

This is where the action form attribute comes into play. Since we have not specified an action yet, HTML defaults to submitting the form data back to the same script that defined the form.

If you would like to have the user navigate to a new URL and handle the form input there, you can specify the URL in the form’s action attribute. Since the action attribute specifies a relative URL, you can also enter the name of a PHP file in the same directory as the current one.

For example, given this directory:

index.php
receive_form.php

To handle a form using receive_form.php from index.php, you would use the following:

<form method="get" action="receive_form.php">

This works for both GET and POST methods.

Instructions
1.

We’ve set up a form to collect a user’s first and last names using the GET method.

Modify the form to use greet_user.php to handle the form input.
2.

Open greet_user.php and replace

<!--Add code here-->

with the user’s name. Use the PHP shorthand for echo within HTML (<?=).

Be sure to use the $_GET superglobal.

You should concatenate (using PHP’s . operator) the user’s first name with a space (" ") and then the user’s last name.


index.php:
<html>
<body>
<form method="get" action="greet_user.php">
First Name:
<input type="text" name="first">
<br>
Last Name:
<input type="text" name="last">
<br>
<input type="submit" value="Submit">
</form>

<a href="index.php">Reset</a>
</body>
</html>

greet_user.php:
<html>
<body>
<p>Thanks!</p>
<p>Your name has been recorded as:</p>
<p><?= $_GET['first']." ".$_GET['last']; ?></p>
<a href="index.php">Reset</a>
</body>
</html>

Booleans and Comparison Operators
Introduction

Have you ever noticed that hyperlinks change color after you click them? If the link has been clicked, then the web browser renders it in purple, rather than blue. The programming concept that makes this possible is called conditionals.

This might be a simple example, but conditionals underlie the complex behavior of computer programs from Gmail, to Mario games, to Microsoft Office. Conditionals make it possible for programs to decide how to react to a wide variety of situations.

But computers aren’t intelligent—in order for them to make decisions they have to be programmed with a set of rules to follow.

In this lesson, we’ll explore how we write programs that can make decisions with conditionals.

If Statements

We’re going to learn about a specific type of conditional called an if statement. An if statement follows this basic structure:

if (/*some condition*/) {
 // Do something...
}

The parentheses hold the condition we want the computer to check. If the condition is true, the code inside the code block ({ }) will run; if it’s not true, the code will not run.

The foundation of any conditional is the boolean data type. A boolean can have one of two values: TRUE or FALSE. Note that these are the words without quotation marks—the string "TRUE" is not the same as the boolean value TRUE. These values are not case sensitive, but we follow the convention of making them uppercase.

If we wanted to write code to approximate our hyperlink example from the previous exercise, we might write something like this:

$is_clicked = TRUE;
if ($is_clicked) {
  $link_color = "purple";
  echo $link_color;
}

In the code above, we ask the computer to check the $is_clicked variable as the condition. If its value is TRUE, the value of $link_color will be assigned "purple" and printed.

In the code above, were our condition not met, we’d skip over the code turning the link purple, but what should we do instead? If the link has been clicked, the color should be purple, otherwise it should be blue. We can include a block of code to run when the condition is not met with the keyword else:

$is_clicked = FALSE;
if ($is_clicked) {
  $link_color = "purple";
  echo $link_color;
} else {
  $link_color = "blue";
  echo $link_color;
}

We changed the value of $is_clicked to FALSE so that the if block will not run. Rather, the else block will run and blue will be printed to the terminal.

Let’s make some conditionals!


Instructions
1.

You’re going to write a function that changes a check box depending on whether the answer given was correct or incorrect.

Write a function markAnswer(). Your function should expect two arguments:

    The first is a boolean value—if the answer was correct, this value will be TRUE otherwise it should be false.
    The second argument will be an associative array representing the checkbox. Since this function will be making permanent changes to the box, it should be passed by reference to the function.

2.

Now to write the meat of the function!

If the answer was correct, the function should change the value at the box’s key of "shape" to "checkmark" and the value at the box’s key of "color" to "green". Otherwise, the function should change the value at the box’s key of "shape" to "x" and the value at the box’s key of "color" to "red".
3.

Time to test your function! We’ve provided two associative arrays for you—each represents a different learner. Invoke your function twice:

    First invoke markAnswer() passing in the value at "is_correct" for $learner_one as well as their "box".
    Next, invoke markAnswer() passing in the value at "is_correct" for $learner_two as well as their "box".
    Finally, use print_r() to print each learners box and make sure they’ve changed as expected.


<?php
namespace Codecademy;

$learner_one = ["is_correct"=>FALSE, "box"=>["shape"=>"none", "color"=>"none"]];
   
$learner_two = ["is_correct"=>TRUE, "box"=>["shape"=>"none", "color"=>"none"]];
  
function markAnswer($boolean, &$array) {
  if($boolean == TRUE) {
    $array['shape'] = "checkmark";
    $array['color'] = "green";
  } else {
    $array['shape'] = "x";
    $array['color'] = "red";
  }
}  

markAnswer($learner_one['is_correct'], $learner_one['box']);
markAnswer($learner_two['is_correct'], $learner_two['box']);

print_r($learner_one['box']);
print_r($learner_two['box']);

Comparison Operators

The condition, or expression, in an if statement can hold a boolean value—like TRUE or FALSE, a variable assigned to one of those values, or an expression that evaluates to TRUE or FALSE.

Just as we can represent a value of five with 5 or with an expression that evaluates to five e.g. 3 + 2, we can write expressions that evaluate to TRUE or FALSE. Comparison operators evaluate a relationship between two operands and return a boolean value.

The less than operator (<) will return TRUE if the left operand is less than the right operand and FALSE if it’s not:

1 < 10; // Evaluates to: TRUE
11 < 3; // Evaluates to: FALSE

The less than or equal to operator (<=) will return TRUE if the left operand is less than or equal to the right operand and FALSE if it’s not:

1 <= 10; // Evaluates to: TRUE
4 <= 4; // Evaluates to: TRUE
18 <= 2; // Evaluates to: FALSE

The greater than operator (>) will return TRUE if the left operand is greater than the right operand and FALSE if it’s not. And the greater than or equal to operator (>=) will return TRUE if the left operand is greater than or equal to the right operand and FALSE if it’s not:

1 > 10; // Evaluates to: FALSE
11 > 3; // Evaluates to: TRUE
1 >= 10; // Evaluates to: FALSE
11 >= 11; // Evaluates to: TRUE
54 >= 10; // Evaluates to: TRUE

Let’s practice writing conditionals using these operators!


1.

Write a function chooseCheckoutLane(). This function should take in a single number argument representing the number of items a customer has. If the customer has 12 items or fewer, the function should return "express lane". Otherwise, the function should return "regular lane".
2.

In the U.S., citizens can vote if they are 18 years old or older. Write a function canIVote() that takes in a number representing an age, and return the string "yes" if they can vote, and the string "no" if they cannot.
3.

We tested your functions to make sure they work with various inputs, but you should be testing your own functions. Test each of your functions twice—once with an input that will enter the if block and once with an input that will enter the else block. Make sure to print the results to the terminal.

<?php
namespace Codecademy;

function chooseCheckoutLane($items)
{
  if ($items <= 12){
    return "express lane";
  } else {
    return "regular lane";
  }
}

function canIVote ($age) 
{
    if($age >= 18){
        return "yes";
       } else {
       return "no";
    }
 }

echo chooseCheckoutLane(1);
echo "\n\n";
echo chooseCheckoutLane(13);
echo "\n\n";
echo canIVote(19);
echo "\n\n";
echo canIVote(13);

Identical and Not Identical Operators

In this exercise we’re going to learn a few more comparison operators and see how we can use them to compare more than just number values.

The identical operator (===) will return TRUE if the left operand is the same as the right operand and FALSE if it’s not:

$num = 5;
$num === 5; // Evaluates to: TRUE
10 === 10; // Evaluates to: TRUE
$num === 20; // Evaluates to: FALSE

When we think about comparing two values, we’ll need to think like a computer. Are "hello" and "Hello" the same?

$greeting = "hello";
$greeting === "hello"; // Evaluates to: TRUE
"hello" === "hel" . "lo";   // Evaluates to: TRUE
$greeting === "HELLO"; // Evaluates to: FALSE

The not identical operator (!==) will return TRUE if the two operators are different and FALSE if they’re the same:

$num = 5;
$num !== 5; // Evaluates to: FALSE
10 !== 10; // Evaluates to: FALSE
$num !== 20; // Evaluates to: TRUE

$greeting = "hello";
"hello" !== "hello"; // Evaluates to: FALSE
$greeting !== "HELLO"; // Evaluates to: TRUE

When looking through PHP code, you may encounter another operator—the equal operator (==). Like the identical operator, the equal operator will return TRUE if the left operand is the same as the right operand and FALSE if it’s not. But the equal operator is less strict than the identical operator and can have some hard to predict results, so we prefer to only use the identical operator.

Awesome. Let’s practice!


Instructions
1.

Write a function agreeOrDisagree() that takes in two strings, and returns "You agree!" if the two strings are the same and "You disagree!" if the two strings are different.
2.

Test your function! Invoke it once with a value that will result in the if block running and once with a value that won’t.
3.

You’re going to write a function to check if it’s time for a user to renew their subscription.

Write a function checkRenewalMonth() that takes in a user’s renewal month as a string (e.g. "January").

Your function should get the current month using the PHP built-in date() function (see the hint for help with this). It should compare the current month to the renewal month passed in. If the renewal month is not the current month, the function should return the string "Welcome!". Otherwise it should return the string "Time to renew".
4.

Test your function! Invoke it once with a value that will result in the if block running and once with a value that won’t.

<?php
namespace Codecademy;

function agreeOrDisagree($string1, $string2) {
  if($string1 === $string2) {
    return "You agree!";
  } else {
    return "You disagree!";
  }
}

echo agreeOrDisagree("Hello", "Hello");
echo agreeOrDisagree("Hello", "Hi");

function checkRenewalMonth($month) {
  $date = date('F');
  if ($month === $date) {
    return "Time to renew";
  } else {
    return "Welcome!";
  }
}

echo checkRenewalMonth ("January");
echo checkRenewalMonth ("March");

Elseif Statements

So far, we’ve been writing conditionals that can only handle one condition. If that condition is met, we do one thing, otherwise we do something else. This only allows us one or two courses of action. But programs can be far more complex.

Consider letter grades on a school assignment:

    If the grade is less than 60, it’s an F
    Or else, if the grade is less than 70, it’s a D.
    Or else, if the grade is less than 80, it’s a C.
    Or else, if the grade is less than 90, it’s a B.
    Or else, it’s an A.

We can write conditionals with multiple if statements using the elseif construction. The computer will continue through each condition until it finds a condition which is met or gets to the end—whichever comes first.

Let’s implement our letter grades example in code:

$grade = 88;
if ($grade < 60) {
  echo "You got an F";
} elseif ($grade < 70) {
  echo "You got a D";
} elseif ($grade < 80) {
  echo "You got a C";
} elseif ($grade < 90) {
  echo "You got a B";
} else {
  echo "You got an A";
}

In the code above, $grade has a value of 88. The computer will check each condition until one is met and run that block of code. When it gets to the condition $grade < 90, it evaluates to TRUE. That code block executes, and You got a B is logged to the terminal.

Notice that the order of our conditionals is important. The grade 55 would satisfy the condition $grade < 90, but it meets the condition intended for it, $grade < 60 first. What if the elseif statements were in a different order?

$grade = 55;
if ($grade < 90) {
  echo "You got a B";
} elseif ($grade < 80) {
  echo "You got a C";
} elseif ($grade < 70) {
  echo "You got a D";
} elseif ($grade < 60) {
  echo "You got an F";
} else {
  echo "You got an A";
}

The code above will output You got a B to the terminal since the computer will run the first TRUE condition. We need to take care when constructing our conditionals that they have the outcome we want.

Note: you may encounter the keywords else if with a space separating the two words. In many situations, else if will work the same way as elseif. Since elseif works more universally, that’s what we choose to use.

Let’s practice writing some elseif statements!


Instructions
1.

You’re going to write a function to determine the likely genetic relationship between two people.

Write a function, whatRelation() that has one number parameter representing the percentage of DNA the two people share. Your function should print the likely relationship as a string. We expect the number passed in to always be an integer from 0 to 100

Here’s how it should calculate the relationship:

    100 should print "identical twins"
    35 through99 should print "parent and child or full siblings"
    14through 34 should print "grandparent and grandchild, aunt/uncle and niece/nephew, or half siblings"
    6 through 13 should print "first cousins"
    3 through 5 should print "second cousins"
    1 through 2 should print "third cousins"
    0 should print "not genetically related"

2.

Test your function with several inputs to make sure it’s working as expected.


<?php
namespace Codecademy;

function whatRelation ($percentSharedDNA)
{
 if ($percentSharedDNA === 100){
   echo "identical twins";
 } elseif ($percentSharedDNA > 34){
   echo "parent and child or full siblings";
 } elseif ($percentSharedDNA > 13){
   echo "grandparent and grandchild, aunt/uncle and niece/nephew, or half siblings";
 }  elseif ($percentSharedDNA > 5) {
   echo "first cousins";
 } elseif ($percentSharedDNA > 2){
   echo "second cousins";
 } elseif ($percentSharedDNA > 0){
   echo "third cousins";
 } else {
   echo "not genetically related";
 }
}

whatRelation(100);
echo "\n\n";
whatRelation(56);
echo "\n\n";
whatRelation(18);
echo "\n\n";
whatRelation(10);
echo "\n\n";
whatRelation(3);
echo "\n\n";
whatRelation(1);

Switch Statement

We often want to compare a value, expression, or variable against many different possible values and run different code depending on which it matches. We can use a series of if/elseif statements which use the identical operator (===) or we can use a switch statement—an alternate syntax.

We wrote some code with if/elseif statements to print a string based on a student’s letter grade:

if ($letter_grade === "A"){
  echo "Terrific";
} elseif ($letter_grade === "B") {
  echo "Good";
} elseif ($letter_grade === "C") {
  echo "Fair";
} elseif ($letter_grade === "D") {
  echo "Needs Improvement";
} elseif ($letter_grade === "F") {
  echo "See me!";
} else {
  echo "Invalid grade"; 
}

Since this code involves a series of comparisons, it’s ripe for a switch statement! Let’s see it refactored with switch:

switch ($letter_grade){
  case "A":
    echo "Terrific";
    break;
  case "B":
    echo "Good";
    break;
  case "C":
    echo "Fair";
    break;
  case "D":
    echo "Needs Improvement";
    break;
  case "F":
    echo "See me!";
    break;
  default:
    echo "Invalid grade"; 
}

We begin the keyword switch followed by the value (or expression) we’ll be comparing—in this case, $letter_grade. We provide possible matches for the expression with the keyword case, the potential matching value, and the colon. For each case, we provide code that should run if that case matches. After each case, we include the keyword break to break out of the switch statement. We can provide a default that should run if none of the provided cases match.

A switch statement is a good example of code that might be preferable not because it’s shorter, but rather because it clearly indicates the purpose of the code; when looking at a switch statement we can quickly identify the important aspects of the code; this makes it easier to understand, extend, and debug.


Switch Statements: Fall through

In the previous exercise, we taught you to use the keyword break after the block for each case. Without the keyword break, not only will the first matching case’s block run, but so will all the code in the subsequent cases! This is known as fall through. The keyword break tells the computer to break out of the switch statement, without it, it will fall through the rest of the switch executing all the code until it reaches a break, a return, or the end of the statement:

$letter = "a";
switch ($letter) {
  case "a":
    echo "a";
  case "b":
    echo "b";
  case "c":
    echo "c";
  case "d":
    echo "d";
}

The code above will output abcd. Only the first case (case "a") actually matches the value of $letter, but since the above code doesn’t have any breaks all of the code in the switch will execute. Fall through may seem like a drag, but it can be useful when we want multiple cases to execute the same code:

switch ($day_of_week) {
  case "Monday":
  case "Tuesday":
    echo "Just getting started!";
    break;
  case "Wednesday":
    echo "Humpday!";
    break;
  case "Thursday":
  case "Friday":
    echo "Almost the weekend!";
    break;
  case "Saturday":
  case "Sunday":
    echo "Enjoy!";
    break;
}

In the code above, we use fall through to our advantage by placing cases that should execute the same code next to each other and having them share a code block. So, for example, if $day_of_week has the value "Monday" or "Tuesday", the string "Just getting started!" will be printed.

It’s ok if you don’t find fall through useful in your own code. But knowing how to use it should remind you that it exists and that you need those breaks!


Instructions
1.

Write a function, returnSeason(). Your function should take in a string representing a month (e.g. "January"), and it should return which season that month falls in.

    "December", "January", and "February" are "winter" months.
    "March", "April", and "May" are "spring" months.
    "June", "July", and "August" are "summer" months.
    And "September", "October", and "November" are "fall" months.

Your function should use a switch statement and fall through to accomplish this task.


<?php
namespace Codecademy;

function returnSeason($month) {
  switch($month) {
    case "December":
    case "January":
    case "February":
      return "winter";
      break;
    case "March":
    case "April":
    case "May":
      return "spring";
      break;
    case "June":
    case "July":
    case "August":
      return "summer";
      break;
    case "September":
    case "October":
    case "November":
      return "fall";
      break;
  }
}

Ternary Operator

PHP offers a short-hand syntax to conditionally return a value. Before learning it, let’s consider some example code:

$isClicked = FALSE;
if ( $isClicked ) {
  $link_color = "purple";
} else {
  $link_color = "blue";
}

In the code above, our condition checks the value of the $isClicked variable. If it’s TRUE we assign $link_color to "purple", otherwise we assign it the value "blue". Our code is somewhat repetitive—the code in each code block is only slightly different.

A ternary operator (?:) is another conditional operator. It takes three operands and returns a value:

    The first operand is a condition to check. This is followed by a question mark ?.
    The second operand is an expression to return if the condition is TRUE. This is followed by a colon (:).
    The third operand is an expression to return if the condition is FALSE.

Let’s see our previous example refactored with the ternary operator:

$isClicked = FALSE;
$link_color = $isClicked ? "purple" : "blue";

The ternary operator allows us to write fewer lines of code while maintaining readability.

Note that code in the expression will be executed, but the intended use of the ternary is to conditionally return a value not to execute code.

Let’s get some practice with the ternary operator!

Instructions
1.

In a previous exercise, you wrote a function chooseCheckoutLane() using an if/else. Write a version of this function called ternaryCheckout() which accomplishes the same functionality using a ternary operator instead of an if/else.

This function should take in a single number argument representing the number of items a customer has. If the customer has 12 items or fewer, the function should return "express lane". Otherwise, the function should return "regular lane".
2.

In a previous exercise, you wrote a function canIVote() using an if/else. Write a version of this function called ternaryVote() which accomplishes the same functionality using a ternary operator instead of an if/else.

Your function should take in a number representing an age, and return the string “yes” if the age is greater than or equal to 18, and the string “no” it’s not.
3.

Test each of your functions twice—once with an input will fulfill the condition and once with an input that won’t. Make sure to print the results to the terminal.

<?php
namespace Codecademy;

function ternaryCheckout($number) {
  $lane = $number <=12 ? "express lane" : "regular lane";
  return $lane;
}

function ternaryVote($age) {
  $vote = $age >= 18 ? "yes" : "no";
  return $vote;
}

echo ternaryCheckout(10);
echo ternaryCheckout(14);

echo ternaryVote(16);
echo ternaryVote(21);

Truthy and Falsy

So far in our conditionals, we’ve been dealing with expressions that would evaluate to boolean values in any context. In practice, any value or expression in the condition will be converted to TRUE or FALSE. Take a look at the following real, working PHP code:

if ("What's going on?"){
  echo "Let us explain…";
} 
// Prints: Let us explain…

In the above code, the condition checks the truthiness of the string "What's going on?". The computer converts this value to TRUE and therefore executes the code in the block. We sometimes refer to code that will be converted to TRUE as truthy and code that will be converted to FALSE as falsy since they aren’t actually equivalent to those boolean values, but they will be treated as such in certain contexts. Most values and expressions are treated as truthy, so we’ll focus on those that are falsy:

    Empty strings
    null
    an undefined or undeclared variable
    an empty array
    the number 0
    the string "0"

Let’s see this in action:

if ("") {
  echo "this will not print";
} elseif (null) {
  echo "this will not print";
} elseif ([]) {
  echo "this will not print";
} elseif (0) {
  echo "this will not print";
} elseif ("0") {
  echo "this will not print";
} else {
  echo "Finally!";
}

Since none of the conditions above hold truthy values, the code will print Finally!.

This can be tricky, so let’s get some practice with it.
Instructions
1.

Since it’s hard to keep track of what’s truthy or falsy in PHP, let’s write a function to check for us! Write a function truthyOrFalsy() that takes in any value and returns the string "True" if that value is truthy and the string "False" if that value is falsy.
2.

Test your function! Invoke your function at least once with a truthy value and at least once with a falsy value. Be sure to use echo to print the results to the terminal.

<?php
namespace Codecademy;

function truthyOrFalsy($value) {
  $result = $value ? "True" : "False";
  return $result;
}

echo truthyOrFalsy(NULL);
echo truthyOrFalsy("hi");

User Input: readline()

The outcomes of programs we’ve been writing so far have been predetermined. Unless we manually change our code, it will produce the same results each time it’s run. But this isn’t very realistic. Programs often receive unexpected inputs or results which is why we need conditionals. Conditionals allow us to write flexible programs that handle this variability.

One common reason our programs need to be flexible is when they have user interaction. When we create a website, we don’t know exactly when a user will press a button or exactly what text they’ll input in a form. Writing programs that can handle unique user interaction is a big part of software development.

User interaction isn’t restricted to web development. We can enable user interaction in our terminal-based programs as well.

The built-in readline() function takes a string with which to prompt the user. It waits for the user to enter text into the terminal and returns that value as a string.

echo "Hi, I'm Aisle Nevertell. What's your name?\n";
$name = readline(">> ");
echo "\nNice to meet you, $name";

The code above prints, Hi, I'm Aisle Nevertell. What's your name?. Then, it prints >> to the terminal to prompt the user to type and awaits their input which it will save in the $name variable. If the user entered Alex, for example, the program would next print Nice to meet you, Alex to the terminal.

By incorporating in conditionals, we can take different actions depending on the user input:

echo "\nWhat's your favorite color?\n";
$color = readline(">> ");
if ($color === "green"){
  echo "\nCool, that's my favorite too!";
} else {
  echo "\nOh, $color is nice, I guess…";
}

In the code above, we prompt the user to enter their favorite color. If they say our favorite color (green), we give one response, otherwise we give a different response.

Let’s practice!
Instructions
1.

In previous exercises that didn’t require user input, we ran your code for you. Now that you’re going to be using the terminal, you’ll also be running your own programs there. To run your program you’ll need to enter php src/index.php in the terminal.

We wrote the first line of a program in src/index.php. Run the program. You should see the text printed to the terminal.
2.

Time to expand the program in src/index.php. Use the readline() function to prompt a user.

You can use whatever you want as the prompt string. We tend to use ">> " or "> " because we feel it gives the user a clear idea of where to type. But test things out and see what you like!

The user will be entering their first name. You should save this response in a variable.
3.

Your program should handle three situations:

    If the user’s name is greater than 8 characters, you should print "Hi, [THEIR NAME]. That's a long name."
    If their name is between 4 and 8 characters (inclusive), you should print "Hi, [THEIR NAME].".
    And if their name is 3 characters or fewer, you should print "Hi, [THEIR NAME]. That's a short name.".

4.

Time to test your code. Run your code a couple times to make sure it’s working as expected.


<?php
namespace Codecademy;

echo "Hello, there. What's your first name?\n";
$name = readline(">> ");
$name_length =  strlen($name);
if($name_length > 8) {
  echo "Hi, $name. That's a long name.";
} elseif ($name_length >= 4) {
  echo "Hi, $name.";
} elseif ($name_length < 4) {
  echo "Hi, $name. That's a short name.";
}
Woah! We covered a lot in this lesson. Good work. Let’s review what we learned:

    Conditionals make it possible for programs to decide how to react to a wide variety of situations.
    if statements allow us to run a block of code if a condition is met.
    The boolean data type is either the value TRUE or FALSE and is the foundation of programmatic decision making.
    We use else to include a block of code to run when the condition is not met.
    Comparison operators evaluate a relationship between two operands and return a boolean value.
        The less than operator (<)
        The less than or equal to operator (<=)
        The greater than operator (>)
        The greater than or equal to operator (>=)
        The Identical operator (===)
        The not identical operator (!==)
    We can write conditionals with multiple if statements using the elseif construction.
    Instead of using a series of if statements when we want to compare a value, expression, or variable against many different possible values and run different code depending on which it matches, we can use a switch statement.
    The keyword break tells the computer to break out of the switch statement, without it, it will fall through the rest of the switch executing all the code until it reaches a break or the end of the statement.
    A ternary operator (?:) is shorthand conditional operator. It takes three operands (a condition to check, an expression to return if the condition is TRUE, and an expression to return if the condition is FALSE).
    Any value or expression inside a condition will be converted to TRUE or FALSE. We consider values that will convert to TRUE to be truthy and values that will convert to FALSE to be falsy.
    We can get user input from the terminal with the readline() function.

That really is a lot… Take some time to practice and review! You’re doing great.


Nested Conditional Statements

In the previous lesson, we explored the foundations of making decisions in programming: booleans and conditionals. In this lesson, we’ll deepen the complexity of our programs’ decision-making capabilities—we’ll be able to make programs where each decision made sends our program on a different route where it might encounter additional decisions.

We wrote some code to illustrate our decision-making process when taking an elevator. Read through the code to make sense of the process:

  $is_elevator_here = true;
  $elevator_direction = "down";
  $my_direction = "up";
  $is_button_pushed = false;

  if ($is_elevator_here){
      if ($elevator_direction === $my_direction){
        echo "I'm in the elevator.";
      } else {
          if ($is_button_pushed){
            echo "I'm waiting...!";
          } else {
              echo "I'm pushing the button.";
          }
     }
  } else {
      if ($is_button_pushed){
          echo "I'm waiting...";
      } else {
          echo "I'm pushing the button.";
      }
   }

Notice that in order to implement this decision-making process with code, we nested conditionals inside each other. This is one way to make more complicated programs. In this lesson, we’ll also learn a new set of operators which will allow us to craft more elaborate decision-making programs. By the end, you’ll be equipped to make powerful, dynamic programs.

Instructions
1.

You’re going to use nested conditionals to create a function both(). Your function should have two boolean parameters. If the first parameter is TRUE and if the second parameter is TRUE, your function should return the string "both". Otherwise, it should return "not both".

There many ways to accomplish this (you’ll learn a great one later in this lesson), but for this task, you need to use nested conditionals.
2.

We tested your function, but you should test it yourself! Invoke your function at least twice—once with inputs that return "both"and once with inputs that return "not both". Be sure to use echo to print the return values to the terminal.


<?php
namespace Codecademy;

function both($bool1, $bool2) {
  if($bool1) {
    if($bool2) {
      return "both";
    } else {
      return "not both";
    }
  } else {
    return "not both";
  }
}

echo both(0, 1);
echo both (1, 1);

The || Operator

Expressions that use logical operators evaluate to boolean values.

The logical operator || takes two different boolean values or expressions as its operands and returns a single boolean value. It returns TRUE if either its left operand or its right operand evaluate to TRUE. We can use || in situations where more than one condition should lead to the same outcome.

TRUE || TRUE;   // Evaluates to: TRUE

FALSE || TRUE;  // Evaluates to: TRUE

TRUE || FALSE;  // Evaluates to: TRUE

FALSE || FALSE; // Evaluates to: FALSE

Let’s think about an example we might encounter in web development: when requesting a password change for a web application, the password can only be changed by either the user themselves or an administrator.

$is_admin = FALSE;
$is_user = TRUE;
if ($is_admin || $is_user){
  echo "You can change the password";
}

In the code above, the condition $is_admin || $is_user evaluates to TRUE and "You can change the password" is printed to the terminal. Note that while $is_admin is FALSE, $is_user is TRUE. The || operator is inclusive—it evaluates to TRUE if either or both of the operands are TRUE.

Instructions
1.

We have a special quirk: we’ll eat only when we’re hungry or if it’s dessert. Somehow we always have room for dessert… Let’s use the logical || operator to represent this situation with code.

Write a function willWeEat(). Your function should take as its first argument a string representing a meal type, and as its second argument a boolean of whether or not we’re hungry.

If either the meal is "dessert" or it’s TRUE that we’re hungry, the function should return "Yum. Thanks!". Otherwise, it should return "No thanks. We're not hungry."

You should use the || operator to accomplish this task.
2.

We tested your function, but you should test it yourself! Invoke your function at least twice—once with inputs that return "Yum. Thanks!"and once with inputs that return "No thanks. We're not hungry.". Be sure to use echo to print the return values to the terminal.

<?php
namespace Codecademy;

function willWeEat($meal, $hungry) {
  if($meal === "dessert" || $hungry) {
    return "Yum. Thanks!";
  } else {
    return "No thanks. We're not hungry.";
  }
}

echo willWeEat("dessert", 0);
echo willWeEat("broccoli", 0);

The && Operator

Often, we’ll encounter situations where we have more than one condition we need satisfied in order to take an action.

The logical && operator returns TRUE only if both of its operands evaluate to TRUE. It returns FALSE if either or both of its operands evaluate to false.

TRUE && TRUE;    // Evaluates to: TRUE
FALSE && TRUE;   // Evaluates to: FALSE
TRUE && FALSE;   // Evaluates to: FALSE
FALSE && FALSE;  // Evaluates to: FALSE

Let’s think about a real-world example: when attempting to withdraw money from an ATM, the account holder must both provide the correct PIN and have enough money in their account.

$correct_pin = TRUE;
$sufficient_funds = TRUE;
if ($correct_pin && $sufficient_funds){
  echo "You can make the withdrawal.";
}

The && operator has a higher operator precedence than the || operator. This means that in a complex statement that includes both operators, the computer will evaluate the part of the expression with && first:

TRUE || TRUE && FALSE // Evaluates to: TRUE

If we want to control the order in which the expression is evaluated, we can use parentheses for force the order:

(TRUE || TRUE) && FALSE // Evaluates to: FALSE

Let’s get some practice with the && operator!


Instructions
1.

There’s a children’s song we always get stuck in our head: If You’re Happy and You Know It. Let’s honor it by translating it into code!

Write a function, clapYourHands(). Your function should take in two boolean arguments. The first represents happiness and the second whether or not they “know it”.

If both are TRUE the function should return the string "CLAP!". Otherwise, it should return the string ":(".

You should use the && operator to accomplish this task.
2.

Test your function! You should invoke your function at least twice—once with inputs that return "CLAP!" and once with inputs that do NOT. Use echo so that the return value of each function call is printed to the terminal.

<?php
namespace Codecademy;

function clapYourHands($happy, $know_it) {
  if($happy && $know_it) {
    return "CLAP!";
  } else {
    return ":(";
  }
}

echo clapYourHands(1, 1);
echo clapYourHands(0, 1);

The Not Operator

The logical not operator (!) takes only a right operand. It reverses the boolean value of its operand.

!TRUE;    // Evaluates to: FALSE
!FALSE;   // Evaluates to: TRUE

The not operator has very high operator precedence; be sure to use parentheses so that code evaluation happens as intended:

!10 < 11; // Evaluates to: TRUE
!(10 < 11);  // Evaluates to: FALSE
!TRUE || TRUE; // Evaluates to: TRUE
!(TRUE || TRUE); // Evaluates to: FALSE

The not operator is useful when we only want to take a course of action if a condition is not true. For example, if a user is not logged in, a web application may show a pop-up telling them they must do so to continue.

$is_logged_in = FALSE; 
if (!$is_logged_in){
  echo "You must log in to continue.";
}

We could accomplish this same functionality without using the ! operator, but look at how much more cumbersome that code is:

$is_logged_in = FALSE; 
if ($is_logged_in){
 // Do nothing... 
} else {
  echo "You must log in to continue.";
}

Let’s practice using the not operator!

Instructions
1.

Let’s play Duck, Duck, Goose. Write a function, duckDuckGoose().

Your function should have one boolean parameter, $is_goose. If $is_goose is FALSE, your function should return "duck". Otherwise, it should return "goose!"

There are several ways you could accomplish this functionality, but since we’re practicing using the ! operator, be sure to use it.
2.

Invoke your function three times and use echo to print the results to the terminal. The first two invocations should result in "duck" being printed, and the third should result in "goose!" being printed.
<?php
namespace Codecademy;

function duckDuckGoose($is_goose){
  if (!$is_goose){
    return "duck";
  } else {
    return "goose!";
  }
}

echo duckDuckGoose(FALSE);
echo "\n";
echo duckDuckGoose(FALSE);
echo "\n";
echo duckDuckGoose(TRUE);

The Xor Operator

The logical operator xor stands for exclusive or. It takes two different boolean values or expressions as its operands and returns a single boolean value. Unlike regular or which evaluates to TRUE if either its left operand or its right operand evaluate to TRUE, xor evaluates to TRUE only if either its left operand or its right operand evaluate to TRUE, but not both.

TRUE xor TRUE;   // Evaluates to: FALSE

FALSE xor TRUE;  // Evaluates to: TRUE

TRUE xor FALSE;  // Evaluates to: TRUE

FALSE xor FALSE; // Evaluates to: FALSE

We can use xor to answer either/or questions: Did you wear either glasses or contacts today?

    If neither, the answer is “No”—I didn’t wear glasses nor did I wear contacts. My vision is impaired.
    If I wore both, the answer is “No”—I didn’t wear either glasses or contacts. My vision is impaired.
    If I wore contacts, the answer is “Yes”—I wore contacts, so my vision was corrected.
    If I wore glasses, the answer is “Yes”—I wore glasses, so my vision was corrected. .

Let’s code up this example:

$is_wearing_glasses = TRUE;
$is_wearing_contacts = TRUE;

if ($is_wearing_glasses xor $is_wearing_contacts){
    echo "Your vision is corrected!";
} else {
    echo "Your vision is impaired.";
}

Let’s practice!


Instructions
1.

We’ll tolerate many ingredients in a pie, but having both bananas and chicken is something we simply can’t condone. And… yet… I must have either bananas or chicken in any pie I eat.

Write a function, eatPie(). Your function should have a single parameter, an array of ingredients. If the array includes either "chicken" or "bananas" (but not both), your function should return "Delicious pie!". Otherwise, it should return "Disgusting!".

You should use xor to accomplish this task.
2.

We’ve provided a couple arrays for you to test your function with. Invoke your function once with the $banana_cream ingredients array and once with the $experimental_pie. Use echo to print the results to the terminal. Make sure it’s working as expected!


<?php
namespace Codecademy;
$banana_cream = ["whole milk", "sugar", "cornstarch", "salt", "egg yolks", "butter", "vanilla extract", "bananas", "heavy cream", "powdered sugar"];
$experimental_pie = ["whole milk", "sugar", "bananas", "chicken", "salmon", "garlic"];

// Write your code below:
function eatPie($ingredients) {
  if(in_array('bananas', $ingredients) xor in_array('chicken', $ingredients)) {
    return "Delicious pie!";
  } else return "Disgusting!";
}

echo eatPie($banana_cream);
echo eatPie($experimental_pie);

Alternate Syntax

An alternate syntax for logical || operator is the or operator, and an alternate syntax for logical && operator is the and operator. These operators have the advantage of making our code more human readable.

// The or Operator:
TRUE or TRUE;   // Evaluates to: TRUE
FALSE or TRUE;  // Evaluates to: TRUE
TRUE or FALSE;  // Evaluates to: TRUE
FALSE or FALSE; // Evaluates to: FALSE

// The and Operator:
TRUE and TRUE;   // Evaluates to: TRUE
FALSE and TRUE;  // Evaluates to: FALSE
TRUE and FALSE;  // Evaluates to: FALSE
FALSE and FALSE; // Evaluates to: FALSE

The computer treats these operators slightly differently from the symbol operators due to operator precedence. The or and and logical operators have a lower precedence than || and &&.

TRUE || TRUE && FALSE // Evaluates to: TRUE
TRUE || TRUE and FALSE // Evaluates to: FALSE

As we mentioned before, we can avoid operator precedence confusion by using parentheses for force the evaluation we want:

(TRUE || TRUE) && FALSE // Evaluates to: FALSE
TRUE || (TRUE and FALSE) // Evaluates to: TRUE

Going forward you can use whichever logical operators you prefer, but let’s get some practice with and and or.

Instructions
1.

Replace the blanks (___) in the code with logical operators (without changing anything else) such that You can change the password. and You can make the withdrawal. are printed to the terminal. You should use and and or to accomplish this task.


<?php
namespace Codecademy;

$is_admin = FALSE;
$is_user = TRUE;
if ($is_admin or $is_user){
  echo "You can change the password.\n";
}


$correct_pin = TRUE;
$sufficient_funds = TRUE;
if ($correct_pin and $sufficient_funds){
  echo "You can make the withdrawal.";
}

Multi-File Programs: include

Separation of concerns is the programming design principle of organizing code into distinct sections each handling a specific task. It enables us to quickly navigate our code and know where to look if something isn’t working. We’ve seen how functions can allow us to practice separation of concerns—by packaging certain routines in functions, we’re able to write cleaner code. But when programs start to get very long, functions aren’t always enough.

Another way to improve our code and separate concerns is with modularity, separating a program into distinct, manageable chunks where each provides a piece of the overall functionality. Instead of having an entire program located in a single file, code is organized into separate files. Each file is then included in our main program with the keyword include. An include statement will bring the code from a file into the current file and also run the code. It’s as if all the code from that file was written right there. We provide the path to the file to be included as a string.

For example, let’s say we had three files one.php, two.php, and index.php, and we want to include the code from files one.php and two.php inside index.php:

// one.php
echo "How are";

// two.php
echo " you?";

// index.php
echo "Hello! ";
include "one.php";
include "two.php";
// Prints: Hello! How are you?

When we run index.php Hello! How are you? is printed to the terminal.

This example is a little silly because we’re barely including any code in the separate files. Let’s get some practice including more significant chunks of code into our main program!


Instructions
1.

Can you make us a sandwich?

We’ve provided several ingredients in multiple files. Your task is to include them in sandwich.php in the correct order.

    top_bread.php
    mayo.php
    lettuce.php
    We need sandwich filling! You’ll have to add these yourself locally in sandwich.php! Use echo to add something really tasty please.
    bottom_bread.php

<?php
include "top_bread.php";
include "mayo.php";
include "lettuce.php";
echo "Delicious chicken cutlet\n";
include "bottom_bread.php";

Review

Great job! You’ve learned the tools needed to craft programs with powerful decision making capabilities. Let’s review what we covered:

    By nesting conditionals within one another, we can create branching decisions.
    The logical operator || takes two different boolean values or expressions as its operands and returns a single boolean value. It returns TRUE if either its left operand or its right operand evaluate to TRUE.
    The logical && operator returns TRUE only if both of its operands evaluate to TRUE. It returns FALSE if either or both of its operands evaluate to FALSE.
    The logical not operator (!) takes only a right operand. It reverses the boolean value of its operand.
    The logical exclusive or operator (xor) returns TRUE only if either its left operand or its right operand evaluate to TRUE, but not both or neither.
    PHP includes alternate syntax for the || and && operators: we can use or in place of ||, and we can use and in place of &&. These operators work much the same way but have different operator precedence.
    We can include code from one file inside another with include which allows us to write mode modular programs.

When attempting to repeat code over and over again, it can be monotonous to retype or copy and paste the same code. Worse, inadvertent typos can cause errors in your program.

Consider an example where you want your code to print the all the numbers from 1 to 10. Without loops, this would look something like:

echo "1\n";
echo "2\n";
echo "3\n";
echo "4\n";
echo "5\n";
echo "6\n";
echo "7\n";
echo "8\n";
echo "9\n";
echo "10";

That’s a lot of typing! And what if you decide later you want to change it to add "The count is currently: " at the beginning of each statement? You would need to copy and paste that into every single line.

Luckily, most programming languages contain a feature, called loops, for repeating code automatically until certain conditions are met. Sometimes the repetition is referred to as iterating and each time the code is executed is considered an iteration. Loops can be used to reduce the number of lines of code while also making it much easier to modify later on.

PHP is no exception and offers several ways to repeat execution of a code block.

This lesson will cover the following PHP loop types:

    while
    do … while
    for
    foreach

Each of these loops contain conditions for stopping execution of the loop. Improper implementation of these conditions can cause an infinite loop and the computer will never stop executing your code block. On Codecademy, if it seems like your code is taking too long or never completes, consider refreshing the page and re-examining your loop structure.


while

The first PHP loop that we will cover is the while loop. This type of loop continues to iterate as long as its conditional is true.

This code outputs the numbers from 1-10, similar to the previous example:

$count = 1;
while ($count < 11)
{
  echo "The count is: " . $count . "\n";
  $count += 1;
}

The first time the interpreter encounters this code, it checks the condition. If it evaluates to TRUE, the code block is executed. It then checks the condition again, and if TRUE, executes the code block again. It continues in this fashion until the condition is FALSE.

In this example, the code within the curly braces ({}) executes while the conditional statement within the brackets ($count < 11) is still true. $count starts at a value of 1 so the conditional is true on the first iteration.

The variable $count is incremented by 1 during each iteration of the loop ($count += 1). When $count is equal to 11, the conditional is no longer true and the while loop terminates. Any code after this block is then executed.

Instructions
1.

We want to examine every number from 1 to 100 and print the number followed by " is divisible by 33\n" if the number is divisible by 33.

Begin by setting up a loop that counts from 1 to 100.

There are many ways to do this, but for this exercise:

    Use a $count variable initially set to 1.
    Use a while loop with a conditional that becomes false when $count is greater than 100.
    Increment $count by 1 at the end of each loop iteration.

2.

At the beginning of the code block within the while loop, add an if statement that only executes if $count is divisible by 33. Use the modulo operator.

The if code block should print the $count followed by " is divisible by 33\n".

<?php
$count = 1;

while($count < 101) {
  if($count % 33 === 0) {
    echo $count." is divisible by 33\n"; 
  }
  $count += 1;
}

do while

A do…while loop is very similar to a while loop. The main difference is that the code block will execute once without the conditional being checked. After the first iteration, it behaves the same as a while loop.

The syntax is slightly different, and the conditional goes at the end of the code block. Our counting to 10 example looks like:

$count = 1;
do {
  echo "The count is: " . $count . "\n";
  $count += 1;
} while ($count < 11);

Unlike the other loop types, the do…while loop requires a semicolon at the end.

In practice, only use this type of loop when you always need the code block to execute at least one time.

For example, if you want to ask a user to guess a secret number, you could use code like:

<?php
do {
  $guess = readline("\nGuess the number\n");
} while ($guess != "42");
echo "\nYou correctly guessed 42!";

This code asks the user to "Guess the number" and continues asking them until they successfully guess 42.

Instructions
1.

For this exercise, we have a plant. We’ve initialized its height using the variable $plant_height to 22. Using a do…while loop, you will be growing the plant by 1 every loop increment. When the plant reaches a height of 30, it is mature and starts producing fruit. At this point, we want to notify the user and exit from the loop.

Begin by establishing an empty do…while loop after the $plant_height initialization. It should continue while the plant is less than or equal to 30. Be sure to increment $plant_height on each loop iteration or you may have an infinite loop!
2.

At the beginning of each loop iteration, we should notify the user of the plant’s height. Add a statement to print "The plant is [X] tall.", with [X] replaced with the current value of $plant_height. Be sure to add a newline after every print statement.
3.

Add an if statement within the loop. When the plant is greater than or equal to 30, you should print "And can produce fruit.".

4.

Now you can see the usefulness of the do…while construct here.

Try changing the initial height to something greater than 30. You will still get notified of the plant’s height and maturity, even though the condition is not met.

<?php
  $plant_height = 32;

  do {
    echo "The plant is $plant_height tall.\n";
    $plant_height += 1;
    if($plant_height >= 31) {
      echo "And can produce fruit.";
    }
  } while ($plant_height <= 30);
  
  for

A for loop is commonly used to execute a code block a specific number of times.

for (#expression 1; #expression 2; #expression 3)
{
  # code block
}

The for loop syntax includes 3 expressions:

    The first is evaluated only one time before the first iteration.
    The second is evaluated before each iteration. If it is TRUE, the code block is executed. Otherwise, the loop terminates.
    The third is evaluated after each iteration. Note that expressions 1 and 2 have semicolons after them.

In our counting to 10 example, the syntax becomes:

for ($count = 1; $count < 11; $count++)
{
  echo "The count is: " . $count . "\n";
}

The first expression is $count = 1, this initializes the $count variable to 1.

At each iteration, the second expression ($count < 11) is evaluated. As long as this is TRUE, the code block executes.

The final expression ($count++) executes after every iteration. In this example, $count is being incremented by 1 each iteration.

After 10 iterations, the value of the $count variable is 11. This makes the second expression FALSE and the loop execution terminates.

Instructions
1.

We’re going to use a for loop to make a countdown. Our goal is to make it count from 10 down to 3 and then say "Ready!", "Set!", "Go!".

Begin by making a for loop that prints the loop variable at each iteration:

    Use $i for your loop variable.
    Initialize $i to 10.
    Continue looping while $i is greater than or equal to zero.
    Decrement $i on each iteration.
    Print $i on each iteration followed by a newline.

2.

Use if, elseif and else statements to modify the output slightly:

    When the loop variable $i is 10 and until its value is down to 3, it should simply print the loop variable followed by a newline.
    When the loop variable is 2, it should print "Ready!", followed by a newline.
    When the loop variable is 1, it should print "Set!", followed by a newline.
    When the loop variable is 0, it should print "Go!".

<?php
  for($i = 10; $i >= 0; $i--) {
    if($i <= 10 and $i >= 3) {
      echo $i."\n";
    } elseif ($i === 2) {
      echo "Ready!\n";
    } elseif($i === 1) {
      echo "Set!\n";
    } else {
      echo "Go!\n";
    }
  }
  
  foreach

The foreach loop is used for iterating over an array. The code block is executed for every element in the array and the value of that element is available for use in the code block.

Our counting to 10 example becomes:

$counting_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
foreach ($counting_array as $count) {
  echo "The count is: " . $count . "\n";
}

Here, we are iterating over $counting_array. On each iteration, the current element in the array is assigned to the variable $count.

We can also iterate over dictionary type arrays with keys and values:

$details_array = ["color" => "blue", "shape" => "square"];
foreach ($details_array as $detail) {
  echo "The detail is: " . $detail . "\n";
}

This will print:

The detail is: blue
The detail is: square

But we can change the syntax slightly to get access to the keys as well as the values:

$details_array = ["color" => "blue", "shape" => "square"];
foreach ($details_array as $attribute => $detail) {
  echo "The " . $attribute . " is: " . $detail . "\n";
}

This will print:

The color is: blue
The shape is: square

Since the loop is controlled by the structure of the array, you can encounter some unexpected behavior if you begin modifying the array during the execution of the foreach loop. If you are going to do this, make sure you have addressed the notes on this in the PHP documentation.
Instructions
1.

In the $scores variable, several student scores are saved. The key for each one is the student’s name.

Make a foreach loop that iterates over the $scores and prints "Someone received a score of [X]." with [X] replaced with their score. Note that we are not using the student names for this step.

Be sure to follow each statement with a newline.
2.

Now we want to see which students received which score. Add a new foreach loop that iterates over $scores but provides access to the key as well as the value.

It should print "[X] received a score of [Y]." with [X] replaced with their name and [Y] replaced with their score.

Be sure to follow each statement with a newline.

<?php
$scores = [
  "Alice" => 99,
  "Bob" => 95,
  "Charlie" => 98,
  "Destiny" => 91,
  "Edward" => 88
];

foreach($scores as $score) {
  echo "Someone received a score of $score \n";
}

foreach($scores as $student => $score) {
  echo "$student received a score of $score \n";
}

Similar to switch statements, the break keyword can be used to terminate any of the loop types early. In our counting example of a while loop, if we add a conditional and a break statement:

$count = 1;
while ($count < 11)
{
  echo "The count is: " . $count . "\n";
  if ($count === 5) {
    break;
  }
  $count += 1;
}

The code will now count from 1 to 5 and then stop.

One downside of heavy usage of break statements is that code can become less readable. In this example, a quick glance might give someone the impression that the loop will iterate until $count is 10. In reality, the buried break statement is controlling the final iteration of the loop.

The continue keyword is similar to break except it only ends the current iteration early, not the entire loop. We could use this in our example to skip counting the number 5:

$count = 1;
while ($count < 11)
{
  if ($count === 5) {
    $count += 1;
    continue;
  }
  echo "The count is: " . $count . "\n";
  $count += 1;
}

Note that we needed to add an extra increment before the continue ($count += 1;) to avoid being caught in an infinite loop.

Instructions
1.

We have given you the countdown code from one of the previous exercises. We’d like to modify it so that it does not print the number 6.

Add an if statement so that when $i is 6, it continues to the next loop iteration and does not print 6.
2.

Now we’d like to end the loop early after printing "Set!". There are a few ways you could do this, but use the keyword that you just learned.

<?php
  for ($i = 10; $i >= 0; $i--) {
    if($i === 6) {
      continue;
    }
    elseif ($i === 2) {
      echo "Ready!\n";
    } elseif ($i === 1) {
      echo "Set!\n";
      break;
    } elseif ($i === 0) {
      echo "Go!\n";
    } else {
      echo $i . "\n";
    }
  }
  
  Review

Now you have the ability to repeat execution of code blocks as necessary in your PHP programs.

Here is a summary of the topics covered in this lesson:

    while loops execute only as long as their conditional evaluates to TRUE.
    do…while loops always execute at least once and then continue executing while their conditional is TRUE.
    for loops contain 3 expressions and are frequently used to execute a code block a specific number of times.
        The first expression is executed prior to the first iteration.
        The second expression is evaluated prior to each iteration. If TRUE, the code block executes. Otherwise, the loop terminates.
        The third expression is evaluated after each iteration.
    foreach loops are used for iterating over the elements of an array. The key and value of each element is available in the code block.
    break is used to end execution of a loop early.
    continue is used to end execution of a loop iteration early and continues to the next iteration.


Why Use Shorthand?

Using the traditional loop syntax in PHP with brackets ({}) to open and close code blocks can be used when embedding PHP code in HTML:

<ul>
<?php
for ($i = 0; $i < 2; $i++) {
?>
<li>Duck</li>
<?php
}
?>
<li>Goose</li>
</ul>

However, when adding nested loops, the readability of the code can suffer. To determine where loops end, we have to count and match brackets.

Luckily, PHP offers an alternate syntax which is especially useful when working with HTML. Instead of using an opening bracket ({), we use a colon (:) and instead of using a closing bracket (}), we use a closing keyword and semicolon (;). For the for loop, the closing keyword is endfor. Our duck, duck, goose example becomes:

<ul>
<?php
for ($i = 0; $i < 2; $i++):
?>
<li>Duck</li>
<?php
endfor;
?>
<li>Goose</li>
</ul>

Now, when reading this code, it becomes immediately apparent that the endfor keyword is closing the for loop.

Why Use Shorthand?

Using the traditional loop syntax in PHP with brackets ({}) to open and close code blocks can be used when embedding PHP code in HTML:

<ul>
<?php
for ($i = 0; $i < 2; $i++) {
?>
<li>Duck</li>
<?php
}
?>
<li>Goose</li>
</ul>

However, when adding nested loops, the readability of the code can suffer. To determine where loops end, we have to count and match brackets.

Luckily, PHP offers an alternate syntax which is especially useful when working with HTML. Instead of using an opening bracket ({), we use a colon (:) and instead of using a closing bracket (}), we use a closing keyword and semicolon (;). For the for loop, the closing keyword is endfor. Our duck, duck, goose example becomes:

<ul>
<?php
for ($i = 0; $i < 2; $i++):
?>
<li>Duck</li>
<?php
endfor;
?>
<li>Goose</li>
</ul>

Now, when reading this code, it becomes immediately apparent that the endfor keyword is closing the for loop.
Instructions
1.

In this file, we’ve used a for loop using bracket syntax to repeat the statement "We sell shoes" 5 times.

Convert this to use the shorthand notation with a colon and closing keyword.

<h1>Only Shoes Shoe Shop</h1>
<?php
for ($i = 0; $i < 5; $i++) :
?>
<p>We sell shoes</p>
<?php
endfor;
?>

Loop Shorthand

We’ve already covered the shorthand for for loops in PHP. The versions for while and foreach loops are very similar.

The only difference is the closing keywords. For a while loop, the closing keyword is endwhile, and for the foreach loop, the closing keyword is endforeach.

Our duck, duck, goose example for the while loop becomes:

<ul>
<?php
$i = 0;
while ($i < 2):
?>
<li>Duck</li>
<?php
$i++;
endwhile;
?>
<li>Goose</li>
</ul>

And the same example using foreach becomes:

<ul>
<?php
$array = [0, 1];
foreach ($array as $i):
?>
<li>Duck</li>
<?php
endforeach;
?>
<li>Goose</li>
</ul>


Instructions
1.

We’ve changed our shoe store example to use a while loop with a nested foreach loop. With this example, the disadvantage to bracket notation starts to become apparent. It’s hard to determine which closing bracket corresponds to the while loop and which corresponds to the foreach loop.

To clean this up, begin by replacing the bracket notation for the while loop with the shorthand version.
2.

Now replace the bracket notation for the foreach loop with the shorthand version.

<h1>Only Shoes Shoe Shop</h1>
<?php
$i = 0;
$repeats = [0, 1];
while ($i < 5) :
?>
<p>We sell shoes</p>
  <?php
  foreach ($repeats as $value) :
  ?>
  <p>(only shoes)</p>
  <?php
  endforeach;
  ?>
<?php
  $i++;
endwhile;
?>

Code Block Considerations

One frequent pattern that we encounter is iterating over an array using a foreach loop and creating HTML elements using the items from the array. The following approach does not work as one might hope:

<?php
$array = ["Alice", "Bob", "Charlie"];
foreach($array as $name): ?>
<p>$name</p>
<?php endforeach; ?>

Since we are in HTML mode and not PHP mode when using $name here, it will simply print $name, instead of the corresponding item from the array.

Because of this behavior, it’s important to remember to re-enter PHP mode before using PHP variables. This can be done using the <?php opening and ?> closing tags. If you are going to simply be printing the variable using echo, you can also use the echo shorthand opening tag (<?=).

With this, our example can be fixed like this:

<?php
$array = ["Alice", "Bob", "Charlie"];
foreach($array as $name): ?>
<p><?=$name?></p>
<?php endforeach; ?>


Instructions
1.

We’ve updated our shoe shop and want to tell the customer how many brands of each type of shoe we stock.

The current code is close, but it is printing the variable names to the site instead of their corresponding values.

Update the code to use the echo shorthand to correctly print the variable values to the browser.


<h1>Shoe Shop</h1>
<?php
$footwear = [
  "sandals" => 4,
  "sneakers" => 7,
	"boots" => 3
];
?>
<p>Our footwear:</p>
<?php
foreach ($footwear as $type => $brands):
?>
<p>We sell <?= $brands ?> brands of <?= $type ?></p>
<?php
endforeach;
?>

Review

With the PHP shorthand you have just learned, you can now create more readable HTML files with embedded PHP loops.

Here are the key ideas from this lesson:

    The PHP shorthand for loops uses a colon (:) instead of a bracket ({) to open the code block.
    The shorthand uses keywords to close the code block instead of a bracket (}):
        Use endfor to close a for loop
        Use endforeach to close a foreach loop
        Use endwhile to close a while loop
    The closing keyword needs to be followed by a semicolon (;).
    Make sure to re-enter PHP mode using <?php or the echo shorthand <?= before using PHP variables in the loop

Introduction

Modern websites require a lot of information to function as intended. Information like our usernames, passwords, “friends”, “likes”, credit card information, and shopping orders all have to be provided by users on the front-end and sent to the web applications’ servers so they can be processed. This information is used to create a personalized experience for the user.

User information is traditionally collected using HTML forms. If you’ve ever entered text in a website, selected from options on a list, or checked boxes and then hit enter or pressed a button, you likely filled out and submitted an HTML form!

In order for the data submitted through forms to be useful, it’s essential that the information is valid—if you were allowed to accidentally submit your last name where your address was expected, your package would never show up!

The process of checking that the information submitted through a form adheres to expectations is called form validation. In this lesson, we’ll explore the different techniques for validating form inputs.
Instructions

Take a look at the form provided. It’s a bare-bones HTML page with no validation. You can play around with it and get to know the different types of inputs on an HTML form.

Think about any of the forms you’ve submitted today—did you log into any sites? Use a search bar? Buy something online?

<!DOCTYPE html>
<html lang="en" dir="ltr">
  <body>
    <h1>Welcome To This Form</h1>
    <form action="" method="POST">
          <label for="text">You can enter text here:</label>
    			<input type="text" name="text">
        <hr>
          <label for="num">You can enter a number here:</label>
          <input type="number" name="num">
        <hr>
          <label for="slider">You can slide this:</label>
          <br>
          <span>Left</span>
          <input type="range" name="slider" value="3" min="1" max="5">
          <span>Right</span>
        <hr>
       <label for="boxes">You can check these:</label>
          <input type="checkbox" name="boxes" value="first">
          <label for="first">First</label>
          <input type="checkbox" name="boxes"  value="second">
          <label for="second">Second</label>
          <input type="checkbox" name="boxes" value="third">
          <label for="third">Third</label>
        <hr>
      <label for="radio">You can select one of these:</label>
          <input type="radio" name="radio" value="true">
          <label for="true">TRUE</label>
          <input type="radio" name="radio" value="false">
          <label for="false">FALSE</label>
        <hr>
          <label for="dropdown">You can select one of these</label>
          <select name="dropdown">
            <option value="first">First</option>
            <option value="second">Second</option>
            <option value="third">Third</option>
          </select>
        <hr>
          <input type="submit" value="Submit to Reset">
      </form>
  </body>
</html>

Why Validate Forms?

Most data, once submitted, is stored by a website or web application. It’s stored in a database on the server side. There are important reasons for us to make sure the information that will be stored in the database is accurate.

We want operations that depend on the data to work: Allowing a user to enter an incorrectly formatted email address, either on purpose or by accident, means that we won’t be able to contact that user later. Allowing a user to sign up for an account with a username that is already in use could cause numerous errors down the line. Making sure we collect all the data we need and checking that the data are formatted correctly can save a web application and its users a lot of trouble.

We want to keep our site secure: Unprotected data leaves entry points for malicious actors to hurt our application or our users. Allowing a user to submit a non-secure password means that their account will not be protected. Unprotected forms can also allow bits of code to be injected into our servers. This can potentially leave our users’ sensitive information exposed. The malicious actor could even gain control of our site or corrupt our existing data!

Regular Expressions

Data submitted through forms are stored as strings. Strings are a fundamental data type in computer science representing a series of characters “strung” together. As humans, we can intuitively recognize patterns within strings, and this allows us to catch errors. Try to notice what’s wrong in the following examples:

    ABCDEF2GHIJKLMNOPQRSTUVWXYZ
    My zip code is 9021
    The ct meowed
    <h1> Hello, World! </h2>

In the first example, we had the letters of the alphabet presented in order but interrupted by an out of place 2. In the second, we left off the 5th digit of a famous zip code. In the third, we omitted the “a” from the word cat. In the final example, we wrote some HTML with an <h1> opening tag but an unmatching </h2> closing tag. If you picked up on these mistakes, it’s because your brain has been trained to expect patterns in certain types of data.

Unlike humans, who can get this training passively over time, computers have to be precisely programmed to recognize patterns. To specify patterns for the computer to recognize, we use a special language called _regular expressions_—also known as regex or regexp. A regular expression is a sequence of characters representing a pattern. We can use that pattern to match a string, match parts of a string, confirm that data is formatted acceptably, or even replace parts of strings with different characters.

Try entering some patterns in the applet provided. If you enter ello, you’ll notice how many of the examples include those characters. We could fully match all of the expressions with the pattern [^]*. To match the first four expressions, we could use a pattern like [hH]ello[^]*. The pattern [^]*\d{3}[^]*\d{3}-\d{4} will match the two example phone numbers. 

Client-side Validation: HTML

The first technique we can use to validate form data is to prevent problematic inputs from being submitted in the first place. This is called client-side validation. The client is the process interacting with the server on behalf of a user—in the case of websites, the web browser is the client. The logic for validating the form is included with the code that displays the form on the user’s device. No interaction with the back-end is required to perform client-side validations.

Since form validation is so common, modern HTML provides some of these validation features built-in. For example, we can use HTML to make parts of a form required and others optional. We can also use HTML to set minimum and maximum values for an input or minimum or maximum lengths for a text input. We can even necessitate that the input match a particular pattern, specified by a regular expression.

If any of the rules laid out in the HTML form validation aren’t followed, the user will not be able to submit their form, and they’ll receive an error message explaining why. With these checks in place, the back-end is less likely to be sent incorrect data. HTML form validation will also benefit the user—the client provides the user immediate feedback, without having to wait for time-consuming communication with the back-end.


Instructions

The provided HTML form has three input fields that are required. Try submitting the form without any one of them. Notice now a message appears on the form. We didn’t have to design that ourselves. It’s built into HTML.

Each input has additional requirements.

    The "name" input requires a text input with a length between 3 and 100.
    The "age" input requires a number value between 1 and 123.
    The "code" input requires an input of either Codecademy or codecademy.

Try out the form with correct and incorrect inputs for each field.

<!DOCTYPE html>
<html lang="en" dir="ltr">
  <body>
    <h1>Basic HTML Validation</h1>
    <form action="" method="POST">
      <label for="text">Enter your name here:</label>
    	<input id="name" name="name" type="text" required minlength="3" maxlength="100">
      <br><br>
      <label for="number">Enter your age here:</label>
      <input type="number" name="age" id="age" required min="1" max="123">
      <br><br>
        <label for="code">Best place to learn to code: (hint: starts with a "C")</label>
  <input id="code" name="code" type="text" required pattern="[cC]odecademy">
      <br><br>
      <input type="submit" value="Submit">
    </form>
  </body>
</html>

Client-side Validation: JavaScript

Client-side validation has two main advantages. First, it’s a better experience for the user to be alerted to problematic data immediately rather than having to wait for that information to come back from the server and have to fill out the form again. Second, catching mistakes earlier in the process saves the application time and resources as well. But not all issues can be handled with the built-in HTML validations.

In order to truly customize validation or to perform more complex validations, we can incorporate JavaScript form validations. We can do this by either writing the JavaScript ourselves or by incorporating a JavaScript library. If we have unique requirements for usernames on our site, for example, we’ll have to provide these systems of validation ourselves.

If we’re creating a relatively simple website, it makes sense to code the form validation ourselves or use a simple vanilla JavaScript library—just-validate, for example. But most basic validation libraries will involve directly accessing or manipulating the DOM. This can get tricky when working with a framework that relies on a virtual DOM—like React or Vue. In those situations, it might be best to incorporate a library that works well with your specific framework. For example, the formik library is a lightweight library that simplifies validating forms in a React app.
Instructions

Play around with the website we’ve provided. It’s a password validator with some specific requirements. This validation is done completely on the client-side using JavaScript. Specifically, it uses a library called Parsley.js.

Back-end Validation

No matter how complete the front-end validation of a website or application seems, validations must also be completed on the back-end or server-side. Front-end validations are easy to bypass—a malicious user can simply turn off JavaScript on their browser, for example. There’s also the potential for middleman attacks in which data is changed after the request is submitted by a user but before it arrives at the server. As a rule, the back-end should never trust the data it receives.

As the developer, once data is in the back-end, we have complete control over it, luckily. Back-end validation has several advantages:

    It enables us to use validation code often on machines with more computing power.
    It allows us to write validation code that a user can’t see—if malicious users can’t see exactly how we validate the data, it’s much more difficult for them to find ways around it.
    We can validate the information against other data the front-end doesn’t have access to—for example, we can check our database to see if a given username is already in use.

There are two main ways to validate inputs on the server-side. The first takes place while the user is still inputting data into the form on the front-end. We can make asynchronous requests to the server with pieces of their data and send feedback directly to the user before they’ve submitted. This is slower than front-end validation and can be a design challenge from a user-experience perspective.

The second is once the form has been submitted. Back-end form validation is our application’s last defense against problematic data, and it’s essential to verify the validity and safety of data before adding it to a database. This is also an opportunity to “sanitize” the data: in order for our database to be useful, it’s important that all data within it is formatted consistently. This means that while we may want to be flexible about the formatting we require from a user, we likely want to transform inputs into a strict format before entering them in the database.


Review

In this lesson, we’ve explored form validation from many angles. Let’s review what we covered:

    Modern websites require a lot of information from their users and they collect a lot of this information through HTML forms.
    It’s essential to validate the data submitted through forms to keep websites secure and to make sure they function correctly.
    Regular expressions are sequences of characters that define patterns to look for in text. They are an important tool used in validating input.
    Modern HTML comes with useful built-in methods for form validation.
    Custom and complicated client-side validation can be accomplished with JavaScript.
    Asynchronous requests to the server can perform back-end validations before a form has been submitted.
    A final back-end validation of all data is required to ensure an application’s security and sanitize all data.

Introduction

When registering an account for a new social media app or completing an order for a gift online, nearly every piece of information you enter into a web form is validated. Did you enter a properly formatted email including an @ symbol? Did you enter a phone number 10 digits long, with or without -s and parentheses? And then there’s the king of them all — did your new password meet the seemingly growing number of requirements for inclusion (and exclusion) of symbols, digits, and both upper and lower case letters?

While correcting each field in our digital lives for proper format can be a pain, it’s integral to ensuring that our accounts are secure, our packages are successfully delivered, and that we can be contacted by phone and email.

The technology that fuels this verification system on nearly every website and application is the ever reliable, often quirky language of regular expressions, commonly shortened to regex, as we will use here, or regexp (pronunciation is up for debate). A regular expression is a special sequence of characters that describe a pattern of text that should be found, or matched, in a string or document. By matching text, we can identify how often and where certain pieces of text occur, as well as have the opportunity to replace or update these pieces of text if needed.

Regular Expressions have a variety of use cases including:

    validating user input in HTML forms
    verifying and parsing text in files, code and applications
    examining test results
    finding keywords in emails and web pages

While there are a variety of implementations of Regular Expressions across platforms, in this lesson you will learn the basics that apply everywhere. By the lesson’s end, you’ll be empowered to use them in your own projects (and become a regex superhero)!
Instructions

Continue to the next exercise to begin your journey into the wild world of regular expressions!

Literals

The simplest text we can match with regular expressions are literals. This is where our regular expression contains the exact text that we want to match. The regex a, for example, will match the text a, and the regex bananas will match the text bananas.

We can additionally match just part of a piece of text. Perhaps we are searching a document to see if the word monkey occurs, since we love monkeys. We could use the regex monkey to match monkey in the piece of text The monkeys like to eat bananas..

Not only are we able to match alphabetical characters — digits work as well! The regex 3 will match the 3 in the piece of text 34, and the regex 5 gibbons will completely match the text 5 gibbons!

Regular expressions operate by moving character by character, from left to right, through a piece of text. When the regular expression finds a character that matches the first piece of the expression, it looks to find a continuous sequence of matching characters.

Instructions
1.

Each exercise in this lesson will have an interactive applet in the browser that allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Each key is part of a URL that contains a surprise you can uncover when you complete the lesson! Add the key to the end of the URL in the code editor and run the code to unlock the next exercise. Move to the next exercise when you are ready!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/on

Alternation

Do you love baboons and gorillas? You can find either of them with the same regular expression using alternation! Alternation, performed in regular expressions with the pipe symbol, |, allows us to match either the characters preceding the | OR the characters after the |. The regex baboons|gorillas will match baboons in the text I love baboons, but will also match gorillas in the text I love gorillas.

Are you thinking about how to match the whole piece of text I love baboons or I love gorillas? We will get to that later on!
Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyour

Spelling tests may seem like a distant memory from grade school, but we ultimately take them every day while typing. It’s easy to make mistakes on commonly misspelled words like consensus, and on top of that, there are sometimes alternate spellings for the same word.

Character sets, denoted by a pair of brackets [], let us match one character from a series of characters, allowing for matches with incorrect or different spellings.

The regex con[sc]en[sc]us will match consensus, the correct spelling of the word, but also match the following three incorrect spellings: concensus, consencus, and concencus. The letters inside the first brackets, s and c, are the different possibilities for the character that comes after con and before en. Similarly for the second brackets, s and c are the different character possibilities to come after en and before us.

Thus the regex [cat] will match the characters c, a, or t, but not the text cat.

The beauty of character sets (and alternation) is that they allow our regular expressions to become more flexible and less rigid than by just matching with literals!

We can make our character sets even more powerful with the help of the caret ^ symbol. Placed at the front of a character set, the ^ negates the set, matching any character that is not stated. These are called negated character sets. Thus the regex [^cat] will match any character that is not c, a, or t, and would completely match each character d, o or g.

Do we have a consensus that regular expressions are pretty cool?

Spelling tests may seem like a distant memory from grade school, but we ultimately take them every day while typing. It’s easy to make mistakes on commonly misspelled words like consensus, and on top of that, there are sometimes alternate spellings for the same word.

Character sets, denoted by a pair of brackets [], let us match one character from a series of characters, allowing for matches with incorrect or different spellings.

The regex con[sc]en[sc]us will match consensus, the correct spelling of the word, but also match the following three incorrect spellings: concensus, consencus, and concencus. The letters inside the first brackets, s and c, are the different possibilities for the character that comes after con and before en. Similarly for the second brackets, s and c are the different character possibilities to come after en and before us.

Thus the regex [cat] will match the characters c, a, or t, but not the text cat.

The beauty of character sets (and alternation) is that they allow our regular expressions to become more flexible and less rigid than by just matching with literals!

We can make our character sets even more powerful with the help of the caret ^ symbol. Placed at the front of a character set, the ^ negates the set, matching any character that is not stated. These are called negated character sets. Thus the regex [^cat] will match any character that is not c, a, or t, and would completely match each character d, o or g.

Do we have a consensus that regular expressions are pretty cool?

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexciting

Wild for Wildcards

Sometimes we don’t care exactly WHAT characters are in a text, just that there are SOME characters. Enter the wildcard .! Wildcards will match any single character (letter, number, symbol or whitespace) in a piece of text. They are useful when we do not care about the specific value of a character, but only that a character exists!

Let’s say we want to match any 9-character piece of text. The regex ......... will completely match orangutan and marsupial! Similarly, the regex I ate . bananas will completely match both I ate 3 bananas and I ate 8 bananas!

What happens if we want to match an actual period, .? We can use the escape character, \, to escape the wildcard functionality of the . and match an actual period. The regex Howler monkeys are really lazy\. will completely match the text Howler monkeys are really lazy..


Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourney

Ranges

Character sets are great, but their true power isn’t realized without ranges. Ranges allow us to specify a range of characters in which we can make a match without having to type out each individual character. The regex [abc], which would match any character a, b, or c, is equivalent to regex range [a-c]. The - character allows us to specify that we are interested in matching a range of characters.

The regex I adopted [2-9] [b-h]ats will match the text I adopted 4 bats as well as I adopted 8 cats and even I adopted 5 hats.

With ranges we can match any single capital letter with the regex [A-Z], lowercase letter with the regex [a-z], any digit with the regex [0-9]. We can even have multiple ranges in the same character set! To match any single capital or lowercase alphabetical character, we can use the regex [A-Za-z].

Remember, within any character set [] we only match one character.
Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve gotten a match!

Enter a regular expression that matches each of the three strings listed below “Match these strings” and does NOT match any of the three strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Copy the key into the code editor and run the code to unlock the next exercise!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourneylearning

Shorthand Character Classes

While character ranges are extremely useful, they can be cumbersome to write out every single time you want to match common ranges such as those that designate alphabetical characters or digits. To alleviate this pain, there are shorthand character classes that represent common ranges, and they make writing regular expressions much simpler. These shorthand classes include:

    \w: the “word character” class represents the regex range [A-Za-z0-9_], and it matches a single uppercase character, lowercase character, digit or underscore
    \d: the “digit character” class represents the regex range [0-9], and it matches a single digit character
    \s: the “whitespace character” class represents the regex range [ \t\r\n\f\v], matching a single space, tab, carriage return, line break, form feed, or vertical tab

For example, the regex \d\s\w\w\w\w\w\w\w matches a digit character, followed by a whitespace character, followed by 7 word characters. Thus the regex completely matches the text 3 monkeys.

In addition to the shorthand character classes \w, \d, and \s, we also have access to the negated shorthand character classes! These shorthands will match any character that is NOT in the regular shorthand classes. These negated shorthand classes include:

    \W: the “non-word character” class represents the regex range [^A-Za-z0-9_], matching any character that is not included in the range represented by \w
    \D: the “non-digit character” class represents the regex range [^0-9], matching any character that is not included in the range represented by \d
    \S: the “non-whitespace character” class represents the regex range [^ \t\r\n\f\v], matching any character that is not included in the range represented by \s

Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!


Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourneylearningto

Grouping

Remember when we were in love with baboons and gorillas a few exercises ago? We were able to match either baboons or gorillas using the regex baboons|gorillas, taking advantage of the | symbol.

But what if we want to match the whole piece of text I love baboons and I love gorillas with the same regex? Your first guess might be to use the regex I love baboons|gorillas. This regex, while it would completely match the string I love baboons, would not match I love gorillas, and would instead match gorillas. This is because the | symbol matches the entire expression before or after itself.

Grouping to the rescue! Grouping, denoted with the open parenthesis ( and the closing parenthesis ), lets us group parts of a regular expression together, and allows us to limit alternation to part of the regex.

The regex I love (baboons|gorillas) will match the text I love and then match either baboons or gorillas, as the grouping limits the reach of the | to the text within the parentheses.

These groups are also called capture groups, as they have the power to select, or capture, a substring from our matched text.
Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourneylearningtocode

Quantifiers - Fixed

Here’s where things start to get really interesting. So far we have only matched text on a character by character basis. But instead of writing the regex \w\w\w\w\w\w\s\w\w\w\w\w\w, which would match 6 word characters, followed by a whitespace character, and then followed by more 6 word characters, such as in the text rhesus monkey, is there a better way to denote the quantity of characters we want to match?

The answer is yes, with the help of quantifiers! Fixed quantifiers, denoted with curly braces {}, let us indicate the exact quantity of a character we wish to match, or allow us to provide a quantity range to match on.

    \w{3} will match exactly 3 word characters
    \w{4,7} will match at minimum 4 word characters and at maximum 7 word characters

The regex roa{3}r will match the characters ro followed by 3 as, and then the character r, such as in the text roaaar. The regex roa{3,7}r will match the characters ro followed by at least 3 as and at most 7 as, followed by an r, matching the strings roaaar, roaaaaar and roaaaaaaar.

An important note is that quantifiers are considered to be greedy. This means that they will match the greatest quantity of characters they possibly can. For example, the regex mo{2,4} will match the text moooo in the string moooo, and not return a match of moo, or mooo. This is because the fixed quantifier wants to match the largest number of os as possible, which is 4 in the string moooo.
Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourneylearningtocodeyou

Quantifiers - Optional

You are working on a research project that summarizes the findings of primate behavioral scientists from around the world. Of particular interest to you are the scientists’ observations of humor in chimpanzees, so you whip up some regex to find all occurrences of the word humor in the documents you have collected. To your dismay, your regex misses the observations of amusement written by scientists hailing from British English speaking countries, where the spelling of the word is humour. Optional quantifiers to the rescue!

Optional quantifiers, indicated by the question mark ?, allow us to indicate a character in a regex is optional, or can appear either 0 times or 1 time. For example, the regex humou?r matches the characters humo, then either 0 occurrences or 1 occurrence of the letter u, and finally the letter r. Note the ? only applies to the character directly before it.

With all quantifiers, we can take advantage of grouping to make even more advanced regexes. The regex The monkey ate a (rotten)? banana will completely match both The monkey ate a rotten banana and The monkey ate a banana.

Since the ? is a metacharacter, you need to use the escape character in your regex in order to match a question mark ? in a piece of text. The regex Aren't owl monkeys beautiful\? will thus completely match the text Aren't owl monkeys beautiful?.
Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourneylearningtocodeyouwill

Quantifiers - 0 or More, 1 or More

In 1951, mathematician Stephen Cole Kleene developed a system to match patterns in written language with mathematical notation. This notation is now known as regular expressions!

In his honor, the next piece of regular expressions syntax we will learn is known as the Kleene star. The Kleene star, denoted with the asterisk *, is also a quantifier, and matches the preceding character 0 or more times. This means that the character doesn’t need to appear, can appear once, or can appear many many times.

The regex meo*w will match the characters me, followed by 0 or more os, followed by a w. Thus the regex will match mew, meow, meooow, and meoooooooooooow.

Another useful quantifier is the Kleene plus, denoted by the plus +, which matches the preceding character 1 or more times.

The regex meo+w will match the characters me, followed by 1 or more os, followed by a w. Thus the regex will match meow, meooow, and meoooooooooooow, but not match mew.

Like all the other metacharacters, in order to match the symbols * and +, you need to use the escape character in your regex. The regex My cat is a \* will completely match the text My cat is a *.
Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourneylearningtocodeyouwillfind

Anchors

When writing regular expressions, it’s useful to make the expression as specific as possible in order to ensure that we do not match unintended text. To aid in this mission of specificity, we can use the anchor metacharacters. The anchors hat ^ and dollar sign $ are used to match text at the start and the end of a string, respectively.

The regex ^Monkeys: my mortal enemy$ will completely match the text Monkeys: my mortal enemy but not match Spider Monkeys: my mortal enemy in the wild or Squirrel Monkeys: my mortal enemy in the wild. The ^ ensures that the matched text begins with Monkeys, and the $ ensures the matched text ends with enemy.

Without the anchor tags, the regex Monkeys: my mortal enemy will match the text Monkeys: my mortal enemy in both Spider Monkeys: my mortal enemy in the wild and Squirrel Monkeys: my mortal enemy in the wild.

Once again, as with all other metacharacters, in order to match the symbols ^ and $, you need to use the escape character in your regex. The regex My spider monkey has \$10\^6 in the bank will completely match the text My spider monkey has $10^6 in the bank.
Instructions
1.

The interactive applet in the browser allows you to enter a regular expression and see if it matches a string of text. If a character is matched, you’ll see it highlighted in green. If there’s a checkmark next to the string, you’ve completely matched the whole piece of text!

Enter a regular expression that matches each of the strings listed below “Match these strings” and does NOT match any of the strings listed below “Don’t match these strings.”

When you’ve entered a regular expression that matches the appropriate strings, a key will appear in the browser. Add the key to the end of the URL in the code editor and run the code to unlock the next exercise!

With this last key, you have the complete URL! Before proceeding to the next exercise, open the link in a new tab and see your surprise :)

Add the hidden key from the browser to the end of the URL given below:

https://s3.amazonaws.com/codecademy-content/courses/regex/onyourexcitingjourneylearningtocodeyouwillfindthis.gif

Review

Do you feel those regular expression superpowers coursing through your body? Do you just want to scream ah+ really loud? Awesome! You are now ready to take these skills and use them out in the wild. Before beginning your adventures, let’s review what we’ve learned.

    Regular expressions are special sequences of characters that describe a pattern of text that is to be matched
    We can use literals to match the exact characters that we desire
    Alternation, using the pipe symbol |, allows us to match the text preceding or following the |
    Character sets, denoted by a pair of brackets [], let us match one character from a series of characters
    Wildcards, represented by the period or dot ., will match any single character (letter, number, symbol or whitespace)
    Ranges allow us to specify a range of characters in which we can make a match
    Shorthand character classes like \w, \d and \s represent the ranges representing word characters, digit characters, and whitespace characters, respectively
    Groupings, denoted with parentheses (), group parts of a regular expression together, and allows us to limit alternation to part of a regex
    Fixed quantifiers, represented with curly braces {}, let us indicate the exact quantity or a range of quantity of a character we wish to match
    Optional quantifiers, indicated by the question mark ?, allow us to indicate a character in a regex is optional, or can appear either 0 times or 1 time
    The Kleene star, denoted with the asterisk *, is a quantifier that matches the preceding character 0 or more times
    The Kleene plus, denoted by the plus +, matches the preceding character 1 or more times
    The anchor symbols hat ^ and dollar sign $ are used to match text at the start and end of a string, respectively



Form Handling

Throughout this lesson, we’ll be using a PHP file to present an HTML form to users. We’ll be using the POST method attribute for more secure input submission. This means all the data submitted will be available in the superglobal associative array: $_POST.

In order for the user’s input to be included in the $_POST array, we provide a name attribute within the HTML. After submitting the form, this name will be the key in the $_POST array and the user’s input will be the value assigned to that key.

<form method="post" action="">
Your Favorite Programming Language: <input type="text" name="language">
<input type="submit" value="Submit Language">
</form>

Above we have an HTML form with a method of "post". We could provide an alternate URL for users to navigate to after submitting their form (eg. action="some_page.php"). Since we want users to have the opportunity to submit the form again if they have errors, we’ll leave the action as an empty string—this means that once it’s submitted, users will be served the same PHP file that originally served them the form. Our form contains an input assigned the name "language". If a user entered “PHP” (as we would assume…) into the language input of the above form and then submitted the form, their URL would not change. However, within the PHP code, the $_POST array would contain a key => value pair of "language" => "PHP".

echo $_POST["language"]; // Prints: PHP

Let’s handle an HTML form with some PHP code!


Instructions
1.

Create a <div> element with an id of "form-output" beneath the form.
2.

Within the <div id="form-output"> element, add a <p> element with an id of "name". Assign the inner HTML of the <p> tag to include the value a user submitted to the "name" input on the form.
3.

Within the <div id="form-output"> element, add a second <p> element with an id of "best". Assign the inner HTML of this <p> tag to include the value a user submitted to the "best" input on the form.


<html>
	<body>
		<form method="post" action="">
			Your name:
			<br>
  		<input type="text" name="name">
 			<br><br>
  		What is the best thing about learning to code:
  		<br>
  		<input type="text" name="best">
  		<br><br> 
  		<input type="submit" value="Submit Answers">
		</form>
    <div id="form-output">
        <p id="name"><?= $_POST["name"] ?></p>
        <p id="best"><?= $_POST["best"] ?></p></div>
		<a href="index.php">Reset</a>
	</body>
</html>
    
	
	Instructions
1.

In the following tasks, you’ll be providing your validation logic within a function that you’ll invoke multiple times within the HTML.

In the PHP section of your code (above the HTML), write a function checkWord(). This function will be used to generate an error if the user submitted a word that does not start with the correct letter.

Your function should have two parameters:

    A string representing the user’s input.
    A string with the letter to which the input is supposed to correspond.

If the form has been submitted ($_SERVER["REQUEST_METHOD"] === "POST") and the first letter in the input is NOT the correct letter, your function should return the following string: "* This word must start with the letter [current letter]!" with [current letter] replaced by the letter currently being tested. Otherwise, your function should return an empty string.

checkWord("apple", "b"); // Returns: "* This word must start with the letter b!"

Note that "A" and "a" are not considered the same value by PHP by default. You can choose whether your function accounts for this or not.
2.

Add three <p> elements to the HTML <form>—one below each <input>. All three should have a class of "error".

    The <p> below the "a-word" input should have an id of "a-error".
    The <p> below the "b-word" input should have an id of "b-error".
    The <p> below the "c-word" input should have an id of "c-error".

The inner HTML of each error <p> element should be assigned to the value returned when your checkWord() function is invoked with the corresponding element from the $_POST array and the appropriate letter.
3.

Assign the value attribute of each input tag to the value submitted by a user. For example, if a user enters the word “apple” in the first input field, they should still see apple in that input field once they submit their form.

<?php
function checkWord($input, $letter){
   if ($_SERVER["REQUEST_METHOD"] === "POST" && strtolower($input[0]) !== $letter) {
    return "* This word must start with the letter ${letter}!";
   } else {
     return "";
   }
}
?>
  
<h1>Time to Practice our ABCs</h1>
<form method="post" action="">
    Enter a word that starts with the letter "a":
    <br>
    <input type="text" name="a-word" id="a-word" value=<?= $_POST["a-word"];?>>
    <br>
    <p class="error" id="a-error"><?= checkWord($_POST["a-word"], "a");?></p>
    <br>
      
    Enter a word that starts with the letter "b":
    <br>
    <input type="text" id="b-word" name="b-word" value=<?= $_POST["b-word"];?>>
    <br>
    <p class="error" id="b-error"><?= checkWord($_POST["b-word"], "b");?></p>
    <br>
    Enter a word that starts with the letter "c":
    <br>
    <input type="text" id="c-word" name="c-word" value=<?= $_POST["c-word"];?>>
    <br>
    <p class="error" id="c-error"><?= checkWord($_POST["c-word"], "c");?></p>
    <br>
    <input type="submit" value="Submit Words">
</form>
<div>
    <h3>"a" is for: <?= $_POST["a-word"];?><h3>
    <h3>"b" is for: <?= $_POST["b-word"];?><h3>
    <h3>"c" is for: <?= $_POST["c-word"];?><h3>    
<div>  

Basic Data Sanitizing

In the previous exercise, we performed a simple validation to check the user’s input, but we made a mistake by directly displaying the data we received from them. Remember that we must never simply trust the data we receive from the client. In order to protect against innocent but dangerous user mistakes, malicious users, or man-in-the-middle attacks, we need to sanitize the data—transform it into a safe and standardized format. In this exercise, we’ll focus on making data safe to display on the user’s browser.

PHP provides several built-in functions to help with sanitization:

We can use the built-in PHP trim() function to remove any whitespace characters from the beginning or end of a string we receive as form input. Though not a security concern, this can help standardize the data prior to validation.

$email = "     aisle.nevertell@yahoo.com   ";
echo trim($email); // Prints: aisle.nevertell@yahoo.com

When we want to display the user’s input within our own HTML, we should first run it through htmlspecialchars(). This built-in function transforms HTML elements into HTML entities (characters that represent HTML elements but won’t display as HTML), so that the PHP interpreter doesn’t recognize them as HTML. This prevents, for example, a man-in-the-middle attack in which malicious HTML is injected into a user’s view of our site.

$data = "<a href=\"https://www.evil-spam.biz/html/\">Your account has been compromised! Click here to get technical support!!</a>";

echo htmlspecialchars($data);

// Prints: &lt;a href=&quot;https://www.evil-spam.biz/html/&quot;&gt;Your account has been compromised! Click here to get technical support!&lt;/a&gt;

Sometimes we will also want to perform custom sanitizations that cannot be accomplished with built-in functions, but we’ll discuss these later in the lesson.

Let’s sanitize some data!
Instructions
1.

Take a look at the form we’ve provided. What happens when you enter <h1>Hello, world!</h1> into the form and submit it?

Change the provided code such that instead of simply displaying the user’s input, their input is run through the htmlspecialchars() function before being displayed.

Make sure the change is working as intended by entering <h1>Hello, world!</h1> into the form and submitting it again.

<form method="post" action="">
Enter some HTML:
<br>
<input type="text" name="html">
<br>  
<input type="submit" value="Submit">
</form>
<div>
  You entered:
	<?= htmlspecialchars($_POST["html"]) ?> 
</div>  

Basic Sanitization with filter_var()

We haven’t yet introduced the most powerful PHP function for sanitizing data: filter_var(). This function operates on a variable and passes it through a “filter” that produces the desired outcome.

As its first argument, filter_var() takes a variable. As its second, it takes an ID representing the type of filtering that should be performed. There are several filters for sanitizing common input types, including FILTER_SANITIZE_EMAIL. The function will return either the sanitized version of the input or FALSE if it was unable to perform the sanitization.

$bad_email = '<a href="www.evil-spam.biz">@gmail.com';
echo filter_var($bad_email, FILTER_SANITIZE_EMAIL);
// Prints: ahref=www.evil-spam.biz@gmail.com  

The FILTER_SANITIZE_EMAIL filter trimmed whitespace throughout our input and removed dangerous characters thus preventing any HTML injection. Essentially, it filtered out any characters not allowed in emails. Once sanitized, we can safely display user inputs.

Of course, $bad_email did not store a valid email in the first place. But since we often want to display invalid form data as a hint for the user, this sanitization would be useful to prevent a man-in-the middle attack. We could also have used htmlspecialchars($bad_email), but that would have produced &lt;a href=&quot;www.evil-spam.biz&quot;&gt;@gmail.com instead. Choose the sanitization method based on the output you want to show to the users.

You can check out the other sanitization filters available in the PHP manual.

Instructions
1.

Take a minute to familiarize yourself with the provided code. We declared three variables: $validation_error, $user_answer, and $submission_response:

    The $validation_error is the inner HTML of our error <span>.
    The $user_answer is assigned to the value attribute of the "answer" input element.
    The $submission_response is included in the inner HTML for the <p> element after the form.

Right now these variables are all assigned empty strings. Notice how when you submit the form, nothing changes. You’ll be changing that in the next task!
2.

In the PHP section of your code (above the HTML), you’ll be writing code to sanitize a user’s input and then generate an error or message depending on whether or not they got the answer right.

You’ll be reassigning the variables we’ve defined for you ($validation_error, $user_answer, and $submission_response) depending on the user’s submission.

If the form has been submitted ($_SERVER["REQUEST_METHOD"] === "POST"), you should assign to $user_answer the value returned from invoking filter_var() with the user’s input. You’ll also need to pass in a sanitization filter designed to sanitize integers. If the form has not been submitted, you shouldn’t do anything.

Once sanitized, you should check whether or not the answer submitted is correct. If the user’s sanitized answer is -5, they got the question right! You should assign $submission_response the string value "Correct!".

If they did not get the correct answer, you should assign $validation_error the string value of "* Wrong answer. Try again.".
3.

Everything should be working properly now. You can try it out for yourself to make sure. What happens when you submit incorrect answers? What about the correct answer? What happens when you submit answers with unacceptable characters?

Notice how an input like <p>-5</p> will get sanitized to -5 and marked as correct.

<?php
$validation_error = "";
$user_answer = "";
$submission_response = "";

// Write your code here:
if($_SERVER["REQUEST_METHOD"] === "POST") {
 $user_answer = filter_var($_POST["answer"], FILTER_SANITIZE_NUMBER_INT);
if ($user_answer != "-5"){
  $validation_error = "* Wrong answer. Try again.";
} else {
  $submission_response = "Correct!";
}
}

?>
<h2>Time for a math quiz!</h2>
<form method="post" action="">
<h4>Question 1:</h4>  
<p>What is 6 - 11?</p> 
<input type="text" name="answer" id="answer" value="<?= $user_answer;?>">
<br>
<span class="error" id="error"><?= $validation_error;?></span> 
<br> 
<input type="submit" value="Submit Your Answer">
</form>
<div>
  <p id="answer-display">Your answer was: <?= $user_answer;?></p>
  <p id="submission-response"><?= $submission_response;?></p>
</div>

Basic Validation with filter_var()

We can use the same filter_var() function to validate as well as sanitize! There are a number of provided validation filters, but they work a bit differently from the sanitization filters. If the variable is deemed valid, filter_var() will return it; otherwise, it will return FALSE:

$bad_email = 'fake - at - prank dot com';
if (filter_var($bad_email, FILTER_VALIDATE_EMAIL)){
  echo "Valid email!";
} else {
  echo "Invalid email!";
} 
// Prints: Invalid email!

It’s worth noting that the provided FILTER_VALIDATE_EMAIL filter is stricter than the guidelines regulating acceptable email addresses. If a site needed to accept non-latin characters, for example, the built-in FILTER_VALIDATE_EMAIL filter wouldn’t be sufficient.

Using the provided validation filters is really convenient. You can check out the list of available validation filters in the PHP manual. For example, FILTER_VALIDATE_URL is useful for checking if a string corresponds to a possible URL.

Let’s practice!

Instructions
1.

Take a minute to familiarize yourself with the provided code. We declared three variables: $validation_error, $user_url, and $form_message:

    The $user_url is assigned to the value attribute of the "url" input element.
    The $validation_error is the inner HTML of our error <span>.
    The $form_message is the inner HTML for the <p> element after the form.

Right now these variables are all assigned empty strings. Notice how when you submit the form, nothing changes. You’ll change that in the next task!
2.

In the PHP section of your code (above the HTML), you’ll be writing code to validate a user’s input and then generate an error or message depending on whether or not their input was valid.

You’ll be reassigning the variables we’ve defined for you ($validation_error, $user_url, and $form_message) depending on the user’s submission.

If the form has been submitted ($_SERVER["REQUEST_METHOD"] === "POST"), you should assign to $user_url the value the user submitted for the "url" input.

You should then validate the $user_url using the filter_var() function and a a validation filter designed to validate URLs. If the form has not been submitted, you shouldn’t do anything.

If the URL is valid, you should assign to $form_message the string value "Thank you for your submission.".

If the URL is not valid, you should assign to $validation_error the string value of "* This is an invalid URL." and $form_message should be assigned the string value "Please retry and submit your form again.".
3.

Check your form with valid and invalid URLs and make sure it’s working properly. Note that a “valid” URL must start with the HTTP protocol (eg. http://).

<?php
$validation_error = "";
$user_url = "";
$form_message = "";

// Write your code here:
if($_SERVER["REQUEST_METHOD"] === "POST") {
  $user_url = $_POST["url"];
  if(filter_var($user_url, FILTER_VALIDATE_URL)) {
     $form_message = "Thank you for your submission."; 
  } else {
    $validation_error = "* This is an invalid URL.";
    $form_message = "Please retry and submit your form again.";
  }
}

Using Options with filter_var()

The filter_var() function accepts an optional third argument that allows us to fine-tune the operation of a given filter. This argument, often called $options, takes the form of a nested associative array.

For example, the $options argument can help us validate that an integer is within a specified range when using the integer validation filter FILTER_VALIDATE_INT. To do this, we set $options to a nested array containing the"min_range" and "max_range" keys in a specific format, shown in the following example:

function validateAdult ($age){
  $options = ["options" => ["min_range" => 18, "max_range" => 124]];  
  if (filter_var($age, FILTER_VALIDATE_INT, $options)) {
    echo("You are ${age} years old.");
  } else {
    echo("That is not a valid age.");
  }
}

validateAdult(18); // Prints: You are 18 years old.
validateAdult(124); // Prints: You are 124 years old.
validateAdult(8); // Prints: That is not a valid age.
validateAdult(200); // Prints: That is not a valid age. 

In the code above, we wrote a function validateAdult() which takes in an $age integer argument. We then used the filter_var() function to validate the integer was between 18 and 124 (inclusive) by using the FILTER_VALIDATE_INT filter and an $options argument with the value ["options" => ["min_range" => 1, "max_range" => 124]].

You can see which filters accept options in the PHP manual.

Instructions
1.

Take a minute to familiarize yourself with the provided code. We declared four variables: $message, $month_error, $day_error, and $year_error. Note: these correspond to keys in the $_POST array.

    These error variables provide the inner HTML to the "error" class <span> elements that follow each input on the form.
    The $message variable provides the inner HTML of the <p> element after the form.

Right now these variables are all assigned empty strings. Notice how when you submit the form, the value attribute of each input field persists, but you don’t receive any other feedback. You’ll change that in the next tasks!
2.

We’re going to be using filter_var() function with the FILTER_VALIDATE_INT validation filter and options arrays.

Create the three options arrays you’ll need:

    Create a variable $month_options. This variable should be assigned an array with a key of "options". The value of the "options" key should be an array providing an acceptable integer range for a valid month: a month can be between 1 and 12 (inclusive).
    Create a variable $day_options. This variable should be assigned an array with a key of "options". The value of the "options" key should be an array providing an acceptable integer range for a valid day: a day can be between 1 and 31 (inclusive).
    Create a variable $year_options. This variable should be assigned an array with a key of "options". The value of the "options" key should be an array providing an acceptable integer range for a valid birth year: we should consider a valid birth year to be any year between 1903 and the current year (inclusive).

3.

To save us from some repetitive code, you’re going to write a function validateInput(). This function will make sure that a user input adheres to specified validation requirements.

Your function should have three parameters:

    The first parameter, $type, will be a string representing the input which is being validated (eg. "month", "day", or "year").
    The second parameter will be an error message passed by reference (&$error). This variable represents the error message that corresponds to the input being checked.
    The third parameter, $options_arr, will be the options array which corresponds to the current input.

Your function should invoke the filter_var() function with the relevant user input from the $_POST array, a filter for validating inputs, and the provided options array.

If the input is deemed invalid, your function should reassign the $error to "* Invalid ${type}" and return FALSE. Otherwise, it should return TRUE.
4.

Great! Now that your function is written, we can actually use it! Uncomment the code after $test_month, after $test_day, and after $test_year. These lines will assign each of those variables to the result of invoking your validateInput() function with each input type.

Once those are uncommented, the form should be working correctly! Test the form with valid and invalid inputs to make sure.

<?php
$message = "";
$month_error = "";
$day_error = "";
$year_error = "";
  
// Create your variables here:
$month_options = ["options" => ["min_range" => 1, "max_range" => 12]];
$day_options = ["options" => ["min_range" => 1, "max_range" => 31]];
$year_options = ["options" => ["min_range" => 1903, "max_range" => 2020]];



// Define your function here:
function validateInput($type, &$error, $options_arr) {
  if(!filter_var($_POST[$type], FILTER_VALIDATE_INT, $options_arr)) {
    $error = "* Invalid ${type}";
    return FALSE;
  } else {
    return TRUE;
  }
}


  if ($_SERVER["REQUEST_METHOD"] === "POST") {
    // Uncomment the code below:
    $test_month = validateInput("month", $month_error, $month_options);
    $test_day = validateInput("day", $day_error, $day_options);
    $test_year = validateInput("year", $year_error, $year_options);    
    if ($test_month && $test_day && $test_year){
      $message = "Your birthday is: {$_POST["month"]}/{$_POST["day"]}/{$_POST["year"]}";
    }  
  }

?>

<form method="post" action="">
	Enter your birthday:
	<br>
	Month: <input type="number" name="month" value="<?= $_POST["month"];?>">
	<span class="error"><?= $month_error;?>		</span>
  <br>
	Day: <input type="number" name="day" value="<?= $_POST["day"];?>">
  <span class="error"><?= $day_error;?>		</span>
	<br>  
	Year: <input type="number" name="year" value="<?= $_POST["year"];?>">  
	<span class="error"><?= $year_error;?>		</span>
	<br>
	<input type="submit" value="Submit">
</form>
    <p><?= $message;?></p>
	
	Custom Validations

We’ll often find the validations offered by built-in functions like filter_var() to be insufficient. When validating all but the simplest data, we’ll likely need to write our own, custom input validations.

A very common method for validating data is to compare the input to a pattern we define with a regular expression. The PHP preg_match() function takes two string arguments: a pattern string with a regular expression and a subject string to check. It returns 1 if it matches, 0 if it doesn’t, and FALSE if there was an error.

For example, we can use the regular expression /^[(]*([0-9]{3})[- .)]*[0-9]{3}[- .]*[0-9]{4}$/ to test for 10-digit North American telephone numbers. It will allow spaces, hyphens, or periods as optional separators as well as optional parentheses around the first three numbers:

$pattern = '/^[(]*([0-9]{3})[- .)]*[0-9]{3}[- .]*[0-9]{4}$/';

preg_match($pattern, "(999)-555-2222"); // Returns: 1

preg_match($pattern, "555-2222"); // Returns: 0

Before we test for regular expression matches, we’ll want to make sure the input isn’t too long. Regular expressions checks can take a lot of computing power—one way a bad actor can damage our website is by submitting extremely long inputs, putting strain on our servers. This can slow down or even crash our site!

We can use the built-in PHP strlen() function to check the length of a given input. Ultimately, the acceptable input length is a judgement call for the web engineer. In this example, we chose 100 characters, but some names can be much longer.

$name = "Aisle Nevertell";
$length = strlen($name);
if ($length > 2 && $length < 100){
  echo "That seems like a reasonable name to me...";
} 

Let’s perform some custom validations!

Instructions
1.

Take a look at the code we’ve provided. The donation form we’re presenting to users has three fields: a number <input> to enter a donation amount, a <select> to choose whether a Mastercard or Visa credit card will be used, and a number <input> to enter a credit card number.

Within the PHP, you’ll be writing the logic to check that the credit card number provided matches the expected format for the type of credit card indicated by the user.

If the user has submitted the form, we’ll want to validate their credit card number. We’ve started you off with an if statement that checks if the form has been submitted. We’ve also reassigned a few variables here:

    The $card_type variable is reassigned from an empty string to the value the user submitted to the "credit" <select> (either "mastercard" or "visa").
    The $card_num variable is reassigned from an empty string to the value the user submitted to the "card-num" <input> (their credit card number).
    The $donation_amount variable is reassigned from an empty string to the value the user submitted to the "amount" <input>.

We’ll break this down into a number of smaller tasks. When you feel like you have a handle on the provided code, click the run button to move on.
2.

Inside the if ($_SERVER["REQUEST_METHOD"] == "POST") block right after the provided variable declarations, add an if/else statement. Your if condition should check that the $card_num is less than 100 characters long.

If $card_num is greater than 100 characters, we won’t want to use regular expression checking, therefore, you should simply assign $feedback the value of $error_message.

We’ll add the logic for what to do if $card_num is less than 100 characters in the step—for now, you can leave it empty.
3.

If $card_num is less than 100 characters, we’ll want to provide additional logic:

Mastercard numbers and Visa numbers are formatted differently, so we’ll want to validate them differently. Create an if/else if block. One should handle if the $card_type type is "mastercard" and the other if it’s "visa".

If the $card_type type is "mastercard", the $card_num should adhere to this regular expression pattern: "/5[1-5][0-9]{14}/". Use preg_match() to check that it does. If so, assign $feedback the value of $success_message. If it does not, assign $feedback the value of $error_message.

If the $card_type type is "visa", the $card_num should adhere to this regular expression pattern: "/4[0-9]{12}([0-9]{3})?([0-9]{3})?/". Use preg_match() to check that it does. If so, assign $feedback the value of $success_message. If it does not, assign $feedback the value of $error_message.

That’s a lot of nested conditions! Walk through your code and make sure it’s the logic you intended.
4.

Awesome! Your function should be working as expected. Test it out with some valid and invalid inputs to see if it’s working as expected.

If you want, you can try to deduce what valid inputs are based on the regular expressions, but check out the hint if you want some examples.


<?php
$feedback = "";
$success_message = "Thank you for your donation!";
$error_message = "* There was an error with your card. Please try again.";

$card_type = "";
$card_num = "";
$donation_amount = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
    $card_type = $_POST["credit"];
    $card_num = $_POST["card-num"];
    $donation_amount = $_POST["amount"];

    if (strlen($card_num)<100){
      if ($card_type === "mastercard"){
        if (preg_match("/5[1-5][0-9]{14}/", $card_num) === 1){
          $feedback = $success_message;
        } else {
          $feedback = $error_message;
        }
  	  } else if ($card_type === "visa") {
        if (preg_match("/4[0-9]{12}([0-9]{3})?([0-9]{3})?/", $card_num) === 1){
          $feedback = $success_message;
        } else {
          $feedback = $error_message;
       }
    }
  } else {
      $feedback = $error_message;
    }
}
?>
<form action="" method="POST">
  <h1>Make a donation</h1>
    <label for="amount">Donation amount?</label>
      <input type="number" name="amount" value="<?= $donation_amount;?>">
      <br><br>
    <label for="credit">Credit card type?</label>
      <select name="credit" value="<?= $card_type;?>">
        <option value="mastercard">Mastercard</option>
        <option value="visa">Visa</option>
      </select>
      <br><br>
      <label for="card-num">Card number?</label>
      <input type="number" name="card-num" value="<?= $card_num;?>">
      <br><br>   
      <input type="submit" value="Submit">
</form>
<span class="feedback"><?= $feedback;?></span>

Validating Against Back-end Data

Because modern websites and web applications need to store a lot of data, they usually interact with databases on the back-end. A common type of custom validation involves comparing user input against information in the database. In this exercise, we’ll practice validating against back-end data using PHP arrays to stand in for complicated databases.

An important application of this kind of validation is handling the creation of a user’s account. Before creating the account, it is very important to check that a submitted username isn’t already being used by someone else! In order to do this, we’ll need to check the database for that username.

In the example below, we model the database of users with the associative array $users, which contains keys in the format "username" => "password".

$users = ["coolBro123" => "password123!", "coderKid" => "pa55w0rd*", "dogWalker" => "ais1eofdog$"];

function isUsernameAvailable ($username){
  global $users;
  if (isset($users[$username])){
    echo "That username is already taken.";
  } else {
    echo "${username} is available.";
  }
}

isUsernameAvailable("coolBro123");
// Prints: That username is already taken. 

isUsernameAvailable("aisleOfPHP");
// Prints: aisleOfPHP is available.

The above function isUsernameAvailable uses the built-in function isset() to check if a given $username exists in the $users array. In production, this check would be done by querying the database.

Instructions
1.

Take a minute to familiarize yourself with the provided code. This PHP serves a log in page to users. We declared five variables at the top of the PHP:

    $users is an associative array with usernames and passwords as key=>value pairs. In production, this type of information would likely be stored in a database.

    $feedback is the text we’ll show to the user depending on whether or not they were able to successfully log in.

    $message is the message we’ll provide as feedback if log-in was successful.

    $validation_error is the error we’ll provide as feedback if their username or password is incorrect.

Once you have a handle on the provided code, run the program and test the form to see how it currently works.
2.

If the form has not been submitted, your PHP code shouldn’t do anything.

Write an if statement that checks the form has been submitted by checking the value of the "REQUEST_METHOD" key on the $_SERVER array.

Within the if block, reassign the $username variable to the value of the "username" key on the $_POST array.

Declare a new variable $password and assign to it the value of the "password" key on the $_POST array.
3.

If a form has been submitted (after $username and $password have been assigned), you’ll need to take two additional steps to validate the user’s login.

    First you’ll need to check that the username exists in the “database”. A username is considered valid if it exists as a key within our $users array.
    You’ll also need to check that the password provided by the user equals the value of that username key in the $users array.

If both of those criteria are met, you should consider the login successful and assign $feedback the value of $message. Otherwise, you should assign $feedback the value of $validation_error.
4.

Awesome! Your code should be working properly. Test it with valid and invalid logins to make sure.

Did you notice we did a couple things differently in this form?

    We didn’t assign the value attribute of the "password" input to the user’s password submission.
    We didn’t give specific feedback about whether it was an invalid username or a bad password that caused the login to fail.

Why do you think we did those things? Check out the hint for an explanation.

<?php
$users = ["coolBro123" => "password123!", "coderKid" => "pa55w0rd*", "dogWalker" => "ais1eofdog$"];  
  
  
$feedback = "";
$message = "You're logged in!";
$validation_error = "* Incorrect username or password.";
$username = "";

// Write your code here:
 if ($_SERVER["REQUEST_METHOD"] === "POST") {
   $username = $_POST["username"];
   $password  = $_POST["password"];
   if (isset($users[$username]) && $users[$username] === $password){
     $feedback = $message;
   } else {
     $feedback = $validation_error;
   }
};

Sanitizing for Back-end Storage

In addition to sanitizing data that is displayed to the user, we always need to sanitize all data before storing it in our own databases. There are serious security concerns with storing data in a database—attempting to store unsanitized inputs into a database can allow a bad actor to corrupt or gain access to sensitive information. To sanitize for back-end security, we will use the methods discussed earlier in this lesson.

We’ll also want to sanitize the formatting: make sure the data stored in our database follows consistent formatting. If we’re going to be displaying or using the data, we’ll want to make sure it always looks the same. So even though we may want to let users input their phone numbers with or without parentheses or dashes, when we store it in the database, we’ll want to change all phone numbers to the same format.

To sanitize data formatting, we can use the built-in preg_replace() function. The preg_replace() takes a regular expression, some replacement text, and a subject string; First, It searches through the subject string for instances that match the regular expression. Then, it outputs a copy of the subject string that has the matched instances replaced by the replacement string:

$one = "codeacademy";
$two = "CodeAcademy";
$three = "code academy";
$four = "Code Academy";

$pattern = "/[cC]ode\s*[aA]cademy/";
$codecademy = "Codecademy";

echo preg_replace($pattern, $codecademy, $one);
// Prints: Codecademy

echo preg_replace($pattern, $codecademy, $two);
// Prints: Codecademy

echo preg_replace($pattern, $codecademy, $three);
// Prints: Codecademy

echo preg_replace($pattern, $codecademy, $four);
// Prints: Codecademy

In the above code, we used the regular expression /[cC]ode\s*[aA]cademy/ which matches most of the common ways people misspell Codecademy. The replacement string is the proper formatting, "Codecademy", meaning that we replaced the matching misspelled versions with the correct spelling and format. Using preg_replace(), we were able to transform the four versions of our company name to the correct version: "Codecademy".

Let’s practice!
Instructions
1.

North American 10-digit phone numbers can be formatted a number of ways: XXX-XXX-XXXX, (XXX) XXX-XXXX, XXX.XXX.XXXX and so on.

We’re creating a form to collect names and phone numbers. Once collected, we want to save the phone numbers to our “database” (here the $contacts array). We’ll need all the phone numbers to be formatted in the exact same way so that we can use them consistently throughout our application. However, we want users to be able to input their phone number in whatever way they prefer.

In these tasks, you’ll be creating the logic to sanitize and validate a user-submitted phone number and then store it in the $contacts array.

Take a look at the provided code, and test out the form to see how it’s working so far.
2.

Add the following logic to the provided if block so that the following steps take place when the form is submitted:

    Check that $number is fewer than 30 characters.
    If it’s greater than 30 characters, assign $message the value of $validation_error.
    If $number is fewer than 30 characters, use the preg_replace() function to remove any character that is NOT the numbers 0 to 9. (The pattern "/[^0-9]/" will match any character besides those numbers, you’ll want to remove them by “replacing” them with an empty string: "").
    Check that the newly formatted phone number is exactly 10 characters.
    If the newly formatted phone number is 10 characters, add the key=>value pair of the user’s name as the key and the reformatted number as the value.
    If the newly formatted phone number is 10 characters, you should also assign $message the string value "Thanks ${name}, we'll be in touch.".
    If the newly formatted phone number is NOT 10 characters, assign $message the value of $validation_error.

3.

Great work! Check your form to make sure everything is working properly.

<?php
$contacts = ["Susan" => "5551236666", "Alex" => "7779991717", "Lily" => "8181117777"];  
$message = "";
$validation_error = "* Please enter a 10-digit North American phone number.";
$name = "";
$number = "";

 if ($_SERVER["REQUEST_METHOD"] == "POST") {
   $name = $_POST["name"];
   $number  = $_POST["number"];
   // Write your code here:
   if (strlen($number)<30){
     $formatted_number = preg_replace("/[^0-9]/", "", $number);
     if (strlen($formatted_number)===10){
       $contacts[$name] = $formatted_number;
       $message = "Thanks ${name}, we'll be in touch.";
     } else {
       $message = $validation_error;
     } 
   } else {
     $message = $validation_error;
   }
   
  
   
   

};
?>
<html>
	<body>
  <h3>Contact Form:</h3>
		<form method="post" action="">
			Name:
			<br>
  		<input type="text" name="name" value="<?= $name;?>">
 			<br><br>
  		Phone Number:
  		<br>
  		<input type="text" name="number" value="<?= $number;?>">
  		<br><br> 
  		<input type="submit" value="Submit">
		</form>
		<div id="form-output">
			<p id="response"><?= $message?></p>
    </div>
	</body>
</html>

Rerouting

In this lesson, we’ve learned some basic tools to validate HTML forms on the back-end using PHP. We learned how to send meaningful feedback to our users when their inputs are invalid. But what should we do if the user has submitted a valid form?

So far, we’ve been sending the users back to the same form whether there were errors in their submission or not. We’ve indicated the form was successfully submitted by conditionally displaying a message, but this isn’t always a great user experience. Think of what happens when you log in to your email. Usually, once a form has been submitted successfully, the user is rerouted to an entirely different page.

We can use the PHP header() function to perform redirects. We call the header() function on a string that begins with "Location: ", followed by the URL we want to redirect the user to. For example: "Location: https://www.best-puppy-pix.com/". After invoking the header() function we’ll want to use the language construct exit to terminate the current script.

To work properly, the header() function needs to be run before anything is output by the script—this includes HTML. So we’ll include it in our PHP script before our file outputs any HTML:

if (/* Is the submission data validated? */) {
  header("Location: https://www.best-puppy-pix.com/");
  exit;
}

Awesome. Let’s try it out!

Instructions
1.

In the code editor, we’ve started you out with the login form we worked on earlier. Previously, when users successfully submitted this form, we merely notified them with a message on the same form. Let’s reroute them to a new page instead!

In the if block where we’ve checked that the username exists and that the provided password matches that username’s password, invoke the header() function.

We’ve provided the HTML file to which users should be routed. Since everything exists within the same directory locally, you should just use the file name as the URL: success.html.

After invoking the header() function, use the exit language construct to stop the script.
2.

Awesome! Everything should be working properly. Check your form with valid and invalid credentials to make sure.

<?php
$validation_error = "";
$username = "";
$users = ["coolBro123" => "password123!", "coderKid" => "pa55w0rd*", "dogWalker" => "ais1eofdog$"];

 if ($_SERVER["REQUEST_METHOD"] === "POST") {
   $username = $_POST["username"];
   $password  = $_POST["password"];
   if (isset($users[$username]) && $users[$username] === $password){
// Add your code here:
    header("Location: success.html");
    exit;
     
   } else {
     $validation_error = "* Incorrect username or password.";
   }
 }

?>
  
<h3>Welcome back!</h3>
<form method="post" action="">
Username:<input type="text" name="username" value="<?php echo $username;?>">
<br>
Password:<input type="text" name="password" value="">
<br>
<span class="error"><?= $validation_error;?></span>
<br>
<input type="submit" value="Log in">
</form>

Review

Great work! We covered a lot in this lesson. Let’s review:

    Performing back-end form validations on the data submitted is an essential step to protect our website and its users.
    Using the POST method attribute in an HTML form gives our PHP script access to data submitted within the superglobal associative array: $_POST.
    We modify our HTML and PHP so that when input is deemed invalid, meaningful feedback is shown to the user.
    If we plan on displaying user input, we need to first sanitize it. We can use methods like trim() and htmlspecialchars() for basic sanitization.
    We can use filter_var() with a filter to sanitize common input types.
    We can also use filter_var() with a filter to perform validations on common input types.
    We’ll often want to perform custom validations.
    The preg_match() function compares checks if a given string matches a regular expression.
    Since regular expression comparisons can consume a lot of computing power, we’ll want to check the length of inputs before performing regular expression checks.
    It’s common to perform validations by comparing user input to back-end data
    Before storing user input in our back-end, we’ll sanitize it for both safety and consistent formatting
    If a user’s form submission has been accepted, we can reroute them to a different page.

Data validation and sanitization is an extremely important part of web development. In this lesson, we’ve covered some of the basic theory and techniques. When developing for production, you’ll need to further research and understands the needs of the specific sites or applications as well as the tools available with the specific databases or frameworks in use.

As your validations get more and more complex, you should also practice modularity and separate your validation logic from your display logic.

Introduction

In our PHP programs so far, we’ve relied on data types built into the language—we’ve used String, Number and Boolean data types directly and saved data in variables. We’ve also used Arrays to organize multiple pieces of data within a single structure.

But sometimes the data types built into the language aren’t enough! Just as we can write custom functions and not depend exclusively on PHP’s built-in functions, we can write custom data types.

In order to define our own data types, we’ll think of the general qualities our user-defined types should have. We’ll create a class —a blueprint defining the related data and functions that should be bundled together inside each instance of this new type. Once the class is defined, we can create specific instances of it—as many as we want! These instances of the class are called objects.
Instructions

Imagine we were creating a Pet class within our program. What sorts of data and functionality should every pet have? Spend some time thinking about this yourself and then feel free to scroll down and look at some of our ideas.


We imagined that pets should have data like their name, color, age. We also thought they might have some functionality like eating and cuddling.

What are Classes?

In the previous exercise, we asked you to imagine a class for pets. Let’s see how we would actually create a PHP Pet class.

To define a Pet class, we use the class keyword followed by the class name (typically title cased in PHP) and curly brackets:

class Pet {

}

Within the curly brackets, we can add properties, which define the data each object of the class will contain. The syntax is similar to how we define variables:

class Pet {
  public $name, $color;
}

Note: The public keyword has to do with something called visibility. We’ll discuss this in depth later in the lesson.

Instructions
1.

Let’s practice defining classes. Start by defining a Beverage class.
2.

Now add some properties to Beverage:

    color
    opacity
    temperature

<?php

class Beverage {
  public $color, $opacity, $temperature;
}

Instantiating

In the previous exercise, we created a class (a blueprint) for any pet we may want to make. But we didn’t make any actual, individual pet objects. Since objects are specific instances of a class, the process of creating them is called instantiation.

In PHP, objects are instantiated using the new keyword followed by the class name and parentheses.

$very_good_dog = new Pet();

We now have our first object, $very_good_dog. We interact with an object’s properties using the object operator (->) followed by the name of the property (without the dollar sign, $).

We can use this syntax to assign values to object properties:

$very_good_dog->name = "Lassie";

We can also use it to access the existing value of object properties:

echo $very_good_dog->name; # Prints "Lassie"

Instructions
1.

We’ve included the Beverage class. Create an instance of this class and assign it to the variable $tea.
2.

Set the temperature of the object to "hot".
3.

Print the value of the temperature property of $tea.

<?php
class Beverage {
  public $temperature, $color, $opacity;
}

$tea = new Beverage;
$tea -> temperature = "hot";

echo $tea -> temperature;

Methods

In addition to properties, we can define class methods – essentially functions each object will contain. Methods are frequently used to interact with an object’s properties in a defined manner.

Methods are defined with the same syntax we use when declaring functions (except they are defined within the curly brackets of a class).

Given a Pet class with first and last name properties, we could provide a method which returns the two properties combined into a full name:

class Pet {
  public $first, $last;
  function getFullName() {
    return $this->first . " " . $this->last;
  }
}

The $this variable refers to the current object; when we invoke this method, $this refers to the specific object that called the method.

Methods are accessed in a similar fashion to properties, using the object operator (->), but in order to invoke them, use parentheses at the end:

$my_object->classMethod();

So, to access the full name of our Pet, we can use the following:

$very_good_groundhog = new Pet();
$very_good_groundhog->first = "Punxsutawney";
$very_good_groundhog->last = "Phil";
echo $very_good_groundhog->getFullName(); # Prints "Punxsutawney Phil"


Instructions
1.

Add a getInfo method to our Beverage class. We’ll be using this method to return some information about our objects.
2.

The method should return this statement about the beverage, with <temperature> and <color> replaced with the beverage’s temperature and color:

"This beverage is <temperature> and <color>."

3.

We’ve created an instance of Beverage and saved it in the variable $soda. We’ve also assigned some values to its properties.

After our code, print the result of calling getInfo on the object (and nothing else).

<?php
class Beverage {
  public $temperature, $color, $opacity;
  function getInfo() {
    return "This beverage is $this->temperature and $this->color.";
  }
}

$soda = new Beverage();
$soda->color = "black";
$soda->temperature = "cold";

echo $soda->getInfo();

Constructor Method

A constructor method is one of several magic methods provided by PHP. This method is automatically called when an object is instantiated. A constructor method is defined with the special method name __construct.

As an example, if we wanted to initialize the deserves_love property assigned to TRUE for every instance of the Pet class, we could use the following constructor:

class Pet {
  public $deserves_love;
  function __construct() {
    $this->deserves_love = TRUE;
  }
}
$my_dog = new Pet();
if ($my_dog->deserves_love){
  echo "I love you!";
}
// Prints: I love you!

Constructors can also have parameters. These correspond to arguments passed in when using the new keyword. For example, maybe we want to allow for setting the name of the Pet on instantiation:

class Pet {
  public $name;
  function __construct($name) {
    $this->name = $name;
  }
} 
$dog = new Pet("Lassie");
echo $dog->name; // Prints: Lassie

In the code above, we instantiate a new Pet object, $dog with a name property assigned to the value "Lassie". Then we access the property and print it.

Keep in mind that the number of arguments used when instantiating the object must match the number of parameters in the constructor definition otherwise PHP will throw an error.

1.

Add a constructor method to our Beverage class.
2.

Modify the constructor to take $temperature and $color arguments (in that order) and set them to their respective object properties.
3.

Test your constructor by instantiating an object with a temperature of "cold" and a color of “black“.

Print the result of calling getInfo on this object.

<?php
class Beverage {
  public $temperature, $color, $opacity;

  function getInfo() {
    return "This beverage is $this->temperature and $this->color.";
    

  }
  function __construct($temperature, $color) {
    $this->temperature = $temperature;
    $this->color = $color;
  }
}

$soda = new Beverage("cold", "black");

echo $soda->getInfo();

Inheritance

Imagine we wanted a Dog class in our program. This class would have all the properties of the more general Pet class, but it would have a few more properties and methods specific to only dogs. Rather than having to manually duplicate the things the two classes have in common, we can create a new class which extends the other. The original class can be thought of as the parent and the new class can be thought of as the child class. In object oriented programming, we call this process inheritance since the child class inherits properties and methods from its parent class. A child class is also referred to as a subclass in PHP.

To define a class that inherits from another, we use the keyword extends:

class ChildClass extends ParentClass {

}

Let’s define a Dog class that extends our Pet class. Each Dog instance will have an additional method called bark():

class Dog extends Pet {
  function bark() {
    return "woof";
  }
}

Now, objects of class Dog can bark, but objects of Pet cannot. This makes sense here, because most dogs can bark, but not all pets can.

Instructions
1.

Add a new class Milk that inherits from Beverage.
2.

We like our milk cold. Within the Milk class, add a constructor that sets the temperature to "cold".

<?php
class Beverage {
  public $temperature;
  
  function getInfo() {
    return "This beverage is $this->temperature.";
  }
}

class Milk extends Beverage {
  function __construct() {
    $this->temperature = "cold";
  }
}

Overloading Methods

Sometimes, we want to change how methods behave for subclasses from the original parent definition. This is called overloading a method. To do this, define a new method within the subclass with the same name as the parent method.

For example, our Pet class might have a type method:

class Pet {
  function type() {
    return "pet";
  }
}

But in our Dog class, we want to update this message:

class Dog extends Pet{
  function whatIsThis() {
    return "dog";
  }
}

We can call the parent’s definition of the method within the subclass using parent:: followed by the method name:

class Dog extends Pet{
  function type() {
    return "dog";
  }
  function classify(){
    echo "This " . parent::type() . " is of type " . $this->type();
    // Prints: This pet is of type dog 
  }
}


Instructions
1.

We’ve added the Milk class from the last exercise. Now we want to update the getInfo method to make it clear that we like our milk cold.

Overload this method to print "This beverage is <temperature>. I like my milk this way.", with <temperature> replaced with the value from the object’s property. Re-use the parent’s implementation of the method within the new definition.
2.

Test the method by creating an instance of Milk and print the result of calling getInfo on it.


<?php
class Beverage {
  public $temperature;
  
  function getInfo() {
    return "This beverage is $this->temperature.";
  }
}

class Milk extends Beverage {
  function __construct() {
    $this->temperature = "cold";
  }
  function getInfo() {
    return "This beverage is $this->temperature. I like my milk this way.";
  }
}

$milk = new Milk;
echo $milk->getInfo();

Visibility - Private Members

To understand visibility we need to think about how classes will be used in complex programs—in large applications, a class might be used in diverse situations (passed around inside functions and used in code written by numerous developers). When we think about our classes being used in many situations, we’ll want to consider restricting access to certain member data.

Up to this point, we’ve been using public visibility for properties. This is also the default visibility for methods. A public visibility means members can be accessed from within the object or from outside it. But sometimes we’ll want a member to only be accessible from within the object. To do this, we can declare this member private.

Let’s look at an example:

class Pet {
  private $healthScore = 0; 
  function exercise(){
    $this->healthScore++;
  }
  function feed(){
    $this->healthScore++;
  }
  function healthCheck(){
    if ($this->healthScore >= 2){
      echo "This is a healthy pet!";
    } else {
      echo "This is an unhealthy pet";
    }
  }
}

In the code above, we have the property healthScore. This is a number we use to calculate the health of a pet. The healthScore property can be manipulated and accessed by member methods, but since we never want the property to be accessed directly outside of the class, we set the property as private. If an attempt is made to access the property directly, our code will raise a Fatal Error.

Instructions
1.

We have three public properties in the Beverage class. Two of these are only accessed within the class, so we can restrict their visibility.

Change the visibility for the temperature and color properties to the most restrictive visibility level.


<?php
class Beverage {
  private $temperature, $color;
  public $opacity;
  function __construct($temperature, $color) {
    $this->temperature = $temperature;
    $this->color = $color;
  }
  function getInfo() {
    return "This beverage is $this->temperature and $this->color.";
  }
}
class Milk extends Beverage {
  function setOpacity($opacity) {
    $this->opacity = $opacity;
  }
}

Visibility - Protected Members

A class’s private members can only be accessed using methods within that class itself. This isn’t usually the desired effect when we have subclasses. For example, the following code will throw a Fatal Error, since healthScore is private to the Pet class and can’t be accessed from the Horse class:

class Pet {
  private $healthScore = 0; 
}

class Horse extends Pet {
  function brushTeeth() {
    this->healthScore++; 
  }
}

$my_pet = new Horse();
$my_pet->brushTeeth(); // Error

To allow members to be accessed from within child classes, we can set the visibility within the parent class to protected rather than private. This enables child classes to access these properties and methods internally while still preventing them from being accessed externally:

class Pet {
  protected $heathScore = 0; 
}

class Horse extends Pet {
  function brushTeeth() {
    this->heathScore++; 
  }
}

$my_pet = new Horse();
$my_pet->brushTeeth(); // Successfully increments healthScore
$my_pet->healthScore; // Error


Instructions
1.

The opacity property is accessed in a subclass, so setting it to private would be too restrictive. However, it is never accessed outside of the class so public is more permissive than we need.

Change the visibility for the opacity to a slightly more restrictive visibility.

<?php
class Beverage {
  private $temperature, $color;
  protected $opacity;
  function __construct($temperature, $color) {
    $this->temperature = $temperature;
    $this->color = $color;
  }
  function getInfo() {
    return "This beverage is $this->temperature and $this->color.";
  }
}
class Milk extends Beverage {
  function setOpacity($opacity) {
    $this->opacity = $opacity;
  }
}
Getters and Setters

The concept of only accessing properties through methods is commonly referred to as using getters and setters.

For example:

class Pet {
  private $name;
  function setName($name) {
    $this->name = $name;
  }
  function getName() {
    return $this->name;
  }
}

This is the most basic way of using getters and setters in PHP. Initially, it may look like it adds little value over making properties public and accessing them directly. But what if we only want to accept a string when setting the name of a Pet?

We can add logic to the setter to ensure that the value being passed in is formatted properly:

function setName($name) {
  if (gettype($name) === "string") {
    $this->name = $name;
    return true;
  } else {
    return false;
  }
}

We added return values to the setter to provide some feedback as to whether the call to setName was successful.

We can also use the getter to format values as they are passed out of the object. In this example, we are capitalizing the first letter of the Pet name:

function getName() {
  return ucfirst($this->name);
}

Instructions
1.

Our Beverage class has a private property color. Add a method called setColor that takes an argument and sets the color property.
2.

Add a method called getColor that returns the value of the color property.
3.

Let’s say we always want to store colors as lowercase. Modify setColor so that it converts the value passed to it to lowercase before assigning it to the property.

<?php
class Beverage {
  private $color;
  function setColor($color) {
    $color = strtolower($color);
    $this->color = $color;
  }
  function getColor() {
    return $this->color;
  }
}

$soda = new Beverage();

Static Members

Instantiating objects is the most common way to use classes and is also the most in-line with OOP principles. Sometimes though, it can be useful to group a set of utility functions and variables together into a single class. Since these don’t change for every instance, we don’t need to instantiate them. We can use them statically.

When a member is intended to be used statically, we add the keyword static to its definition.

Consider this class with a static property and a static method:

class StringUtils {
  public static $max_number_of_characters = 80;
  public static function uclast($string) {
    $string[strlen($string)-1] = strtoupper($string[strlen($string)-1]);
    return $string;
  }
}

Accessing these static members is done a little differently than with objects. We need to use the Scope Resolution Operator (::). This can be thought of as switching briefly into the scope of the class itself. Since we are inside the scope, we access properties with the dollar sign. For example:

echo StringUtils::$max_number_of_characters; # Prints "80"

Methods are accessed by using the method name:

echo StringUtils::uclast("hello world"); # Prints "hello worlD"



Instructions
1.

We’ve defined a utility class, AdamsUtils. Currently its members are not static.

Make $the_answer and addTowel static.
2.

Access both members of AdamsUtils statically and print them using echo. Pass $items as an argument for the static method.

<?php
class AdamsUtils {
  public static $the_answer = 42;
  public static function addTowel($string) {
    return $string . " and a towel.";
  }
}

$items = "I brought apples";

echo AdamsUtils::$the_answer;
echo AdamsUtils::addTowel($items);

Review

Now you have the knowledge to create your own classes and objects in PHP using OOP! Take some time to review the concepts before moving on:

    Classes are defined using the class keyword.
    Functions defined within a class become methods and variables within the class are considered properties.
    There are three levels of visibility for class members:
        public (default) - accessible from outside of the class
        protected - only accessible within the class or its descendants
        private - only accessible within the defining class
    Members can be defined to be static.
        Static members are accessed using the Scope Resolution Operator (::).
    Classes are instantiated into objects using the new keyword.
        Members of an object are accessed using the Object Operator (->).

